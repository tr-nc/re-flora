#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_ShadowCameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
shadow_camera_info;
#include "../include/contree_node.glsl"
layout(set = 0, binding = 1) readonly buffer B_ContreeNodeData { ContreeNode data[]; }
contree_node_data;
layout(set = 0, binding = 2) readonly buffer B_ContreeLeafData { uint data[]; }
contree_leaf_data;
layout(set = 0, binding = 3, rg32ui) readonly uniform uimage3D scene_tex;
layout(set = 0, binding = 4, r32f) uniform image2D shadow_map_tex;

#include "../include/contree_marching.glsl"
#include "../include/core/packer.glsl"
#include "../include/marching_result.glsl"
#include "../include/ray.glsl"

bool scene_hit(inout MarchingResult o_res, vec3 o, vec3 d, ivec3 map_pos, uvec4 scene_tex_read) {
    // see update_scene_tex.comp for encoding part
    if (scene_tex_read.x == 0) {
        return false;
    }
    scene_tex_read -= 1;

    ContreeMarchingResult contree_res =
        contree_marching(o, d, map_pos, vec3(1.0), false, scene_tex_read.x, scene_tex_read.y);
    if (contree_res.is_hit) {
        uint voxel_data       = contree_leaf_data.data[contree_res.voxel_addr];
        o_res.is_hit          = true;
        o_res.pos             = contree_res.pos;
        o_res.center_pos      = contree_res.center_pos;
        o_res.is_normal_valid = (voxel_data & (1u << 29)) != 0u;
        o_res.normal          = unpack_normal_v2((voxel_data & 0x1FFFFF00u) >> 8);
        o_res.voxel_type      = voxel_data & 0xFFu;
        o_res.voxel_addr      = contree_res.voxel_addr;
        return true;
    }
    return false;
}
#include "../include/dda_scene_marching.glsl"

///

MarchingResult general_scene_marching(Ray ray) {
    return dda_scene_marching(ray.origin, ray.direction, ray.inv_direction);
}

float get_pixel_depth(Ray ray) {
    MarchingResult res_primary_ray = general_scene_marching(ray);

    if (!res_primary_ray.is_hit) {
        return 1.0;
    }
    vec4 point_ndc         = shadow_camera_info.view_proj_mat * vec4(res_primary_ray.pos, 1.0);
    float primary_depth_01 = point_ndc.z / point_ndc.w;
    return primary_depth_01;
}

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(shadow_map_tex);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(screen_uv, shadow_camera_info.view_proj_mat_inv);

    float terrain_depth = get_pixel_depth(ray);

    float existing_depth = imageLoad(shadow_map_tex, uvi).r;
    float final_depth = min(terrain_depth, existing_depth);

    // float final_depth = terrain_depth;

    imageStore(shadow_map_tex, uvi, vec4(final_depth, 0.0, 0.0, 0.0));
}
