// From Douglas:
// - The screen is divided into 8x8 pixel tiles. The maximum depth traveled by any primary ray in
// the 8x8 pixels is determined using workgroup atomics.
// - A line segment is constructed from the camera to that maximum depth, representing the rough
// path that rays in the 8x8 tile traveled.
// - The line segment is divided into 64 pieces. Each pixel in the 8x8 tile traces one ray toward
// the sun.
// - The results are accumulated using workgroup atomics and written to a low-res texture.
// - The low-res texture is composited onto the final image.

#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_CameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 1) uniform U_ShadowCameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
shadow_camera_info;
layout(set = 0, binding = 2) uniform U_GodRayInfo { float max_depth; }
god_ray_info;
layout(set = 0, binding = 3, r32f) uniform readonly image2D gfx_depth_tex;
layout(set = 0, binding = 4, r32f) uniform readonly image2D compute_depth_tex;
layout(set = 0, binding = 5) uniform sampler2D vsm_shadow_map_tex;
layout(set = 0, binding = 6, rgba32f) uniform writeonly image2D god_ray_output_tex;

#include "../include/ray.glsl"
#include "../include/vsm.glsl"

const uint MAX_CHECKS = 64;

float get_depth_01(ivec2 uvi) {
    // float gfx_depth_01     = imageLoad(gfx_depth_tex, uvi).r;
    float compute_depth_01 = imageLoad(compute_depth_tex, uvi).r;
    // return min(gfx_depth_01, compute_depth_01);
    return compute_depth_01;
}

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(gfx_depth_tex);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    float depth_01 = get_depth_01(uvi);

    vec2 screen_uv = (vec2(uvi) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(screen_uv, camera_info.view_proj_mat_inv);

    vec4 near_point_ndc = vec4(screen_uv * 2.0 - 1.0, 0.0, 1.0);
    vec3 near_point_ws  = ndc_to_world(near_point_ndc, camera_info.view_proj_mat_inv);

    vec4 hit_far_point_ndc = vec4(screen_uv * 2.0 - 1.0, depth_01, 1.0);
    vec3 hit_far_point_ws  = ndc_to_world(hit_far_point_ndc, camera_info.view_proj_mat_inv);

    float real_depth = length(hit_far_point_ws - near_point_ws);

    float step_size   = god_ray_info.max_depth / MAX_CHECKS;
    float using_depth = min(real_depth, god_ray_info.max_depth);

    float shadow_visibility = 0.0;
    for (uint i = 0; i < MAX_CHECKS; i++) {
        float current_depth = i * step_size;
        if (current_depth < using_depth) {
            vec4 lookup_pos  = vec4(ray.origin + ray.direction * current_depth, 1.0);
            float shadow_vsm = get_shadow_vsm(shadow_camera_info.view_proj_mat, lookup_pos);
            shadow_visibility += shadow_vsm;
        }
    }
    shadow_visibility /= MAX_CHECKS;
    imageStore(god_ray_output_tex, uvi, vec4(shadow_visibility, 0.0, 0.0, 1.0));
}
