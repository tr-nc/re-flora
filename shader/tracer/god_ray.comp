// From Douglas:
// - The screen is divided into 8x8 pixel tiles. The maximum depth traveled by any primary ray in
// the 8x8 pixels is determined using workgroup atomics.
// - A line segment is constructed from the camera to that maximum depth, representing the rough
// path that rays in the 8x8 tile traveled.
// - The line segment is divided into 64 pieces. Each pixel in the 8x8 tile traces one ray toward
// the sun.
// - The results are accumulated using workgroup atomics and written to a low-res texture.
// - The low-res texture is composited onto the final image.

#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_CameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 1) uniform U_ShadowCameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
shadow_camera_info;
layout(set = 0, binding = 2) uniform U_GodRayInfo { float max_depth; }
god_ray_info;
layout(set = 0, binding = 3) uniform U_EnvInfo { uint frame_serial_idx; }
env_info;
layout(set = 0, binding = 4, r32f) uniform readonly image2D gfx_depth_tex;
layout(set = 0, binding = 5, r32f) uniform readonly image2D compute_depth_tex;
// we don't use the filtered VSM texture here, just use the plain shadow map texture
layout(set = 0, binding = 6, r32f) readonly uniform image2D shadow_map_tex;
layout(set = 0, binding = 7, rgba32f) uniform writeonly image2D god_ray_output_tex;

layout(set = 1, binding = 0, r8) readonly uniform image2DArray scalar_bn;
layout(set = 1, binding = 1, rg8) readonly uniform image2DArray unit_vec2_bn;
layout(set = 1, binding = 2, rgba8) readonly uniform image2DArray unit_vec3_bn;
layout(set = 1, binding = 3, rgba8) readonly uniform image2DArray weighted_cosine_bn;
layout(set = 1, binding = 4, rgba8) readonly uniform image2DArray fast_unit_vec3_bn;
layout(set = 1, binding = 5, rgba8) readonly uniform image2DArray fast_weighted_cosine_bn;
#include "../include/noise_tex.glsl"

#include "../include/ray.glsl"

const float MAX_DEPTH = 1.5;
const uint MAX_CHECKS = 64;

float get_depth_01(ivec2 uvi) {
    // float gfx_depth_01     = imageLoad(gfx_depth_tex, uvi).r;
    float compute_depth_01 = imageLoad(compute_depth_tex, uvi).r;
    // return min(gfx_depth_01, compute_depth_01);
    return compute_depth_01;
}

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(gfx_depth_tex);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    float depth_01 = get_depth_01(uvi);

    vec2 screen_uv = (vec2(uvi) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(screen_uv, camera_info.view_proj_mat_inv);

    vec4 near_point_ndc = vec4(screen_uv * 2.0 - 1.0, 0.0, 1.0);
    vec3 near_point_ws  = ndc_to_world(near_point_ndc, camera_info.view_proj_mat_inv);

    vec4 hit_far_point_ndc = vec4(screen_uv * 2.0 - 1.0, depth_01, 1.0);
    vec3 hit_far_point_ws  = ndc_to_world(hit_far_point_ndc, camera_info.view_proj_mat_inv);

    float real_depth = length(hit_far_point_ws - near_point_ws);

    float step_size   = MAX_DEPTH / MAX_CHECKS;
    float using_depth = min(real_depth, MAX_DEPTH);

    ivec3 seed         = get_seed(env_info.frame_serial_idx);
    float random_float = random_float_bn(seed);

    // -----------------------------------------------------------------------------
    // Accumulate lit length along the ray (Riemann sum)
    // -----------------------------------------------------------------------------
    float shadow_visibility = 0.0;

    for (uint i = 0; i < MAX_CHECKS; ++i) {
        float current_depth = (random_float + float(i)) * step_size;
        if (current_depth >= using_depth) break; // past the hit

        vec4 lookup_pos = vec4(ray.origin + ray.direction * current_depth, 1.0);

        vec4 light_space       = shadow_camera_info.view_proj_mat * lookup_pos;
        vec3 ndc               = light_space.xyz / light_space.w;
        vec2 uv                = ndc.xy * 0.5 + 0.5;
        float t                = ndc.z;
        float shadow_tex_depth = imageLoad(shadow_map_tex, ivec2(uv * imageSize(shadow_map_tex))).r;

        // If the current point in the atmosphere can be lit
        if (shadow_tex_depth > t) {
            float mist_weight = exp(-lookup_pos.y * 2.0);
            shadow_visibility += mist_weight * step_size; // weight by segment length
        }
    }

    // Convert the path-length sum to the [0,1] range
    float inv_total_len = 1.0 / max(using_depth, 1e-4); // avoid /0
    shadow_visibility *= inv_total_len;

    imageStore(god_ray_output_tex, uvi, vec4(shadow_visibility, 0.0, 0.0, 1.0));
}
