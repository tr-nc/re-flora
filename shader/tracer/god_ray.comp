#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_CameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 1) uniform U_ShadowCameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
shadow_camera_info;
layout(set = 0, binding = 2) uniform U_EnvInfo { uint frame_serial_idx; }
env_info;
layout(set = 0, binding = 3) uniform U_GodRayInfo {
    float max_depth;
    uint max_checks;
    uint is_using_dynamic_step_size;
}
god_ray_info;
layout(set = 0, binding = 4, r32f) uniform readonly image2D gfx_depth_tex;
layout(set = 0, binding = 5, r32f) uniform readonly image2D compute_depth_tex;
layout(set = 0, binding = 6) uniform sampler2D shadow_map_tex;
layout(set = 0, binding = 7, r32f) uniform writeonly image2D god_ray_output_tex;

layout(set = 1, binding = 0, r8) readonly uniform image2DArray scalar_bn;
layout(set = 1, binding = 1, rg8) readonly uniform image2DArray unit_vec2_bn;
layout(set = 1, binding = 2, rgba8) readonly uniform image2DArray unit_vec3_bn;
layout(set = 1, binding = 3, rgba8) readonly uniform image2DArray weighted_cosine_bn;
layout(set = 1, binding = 4, rgba8) readonly uniform image2DArray fast_unit_vec3_bn;
layout(set = 1, binding = 5, rgba8) readonly uniform image2DArray fast_weighted_cosine_bn;
#include "../include/noise_tex.glsl"

#include "../include/ray.glsl"


float get_depth_01(ivec2 uvi) {
    float gfx_depth_01     = imageLoad(gfx_depth_tex, uvi).r;
    float compute_depth_01 = imageLoad(compute_depth_tex, uvi).r;
    return min(gfx_depth_01, compute_depth_01);
}

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(gfx_depth_tex);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    float depth_01 = get_depth_01(uvi);

    vec2 screen_uv = (vec2(uvi) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(screen_uv, camera_info.view_proj_mat_inv);

    vec4 near_point_ndc = vec4(screen_uv * 2.0 - 1.0, 0.0, 1.0);
    vec3 near_point_ws  = ndc_to_world(near_point_ndc, camera_info.view_proj_mat_inv);

    vec4 hit_far_point_ndc = vec4(screen_uv * 2.0 - 1.0, depth_01, 1.0);
    vec3 hit_far_point_ws  = ndc_to_world(hit_far_point_ndc, camera_info.view_proj_mat_inv);

    float real_depth = length(hit_far_point_ws - near_point_ws);

    float using_depth = min(real_depth, god_ray_info.max_depth);
    
    float step_size;
    if (god_ray_info.is_using_dynamic_step_size != 0) {
        // Dynamic step size: adapt to actual depth
        step_size = using_depth / float(god_ray_info.max_checks);
    } else {
        // Fixed step size: based on max depth
        step_size = god_ray_info.max_depth / float(god_ray_info.max_checks);
    }

    ivec3 seed         = get_seed(env_info.frame_serial_idx);
    float random_float = random_float_bn(seed);

    // accumulate lit length along the ray (Riemann sum)
    float shadow_visibility = 0.0;

    for (uint i = 0; i < god_ray_info.max_checks; ++i) {
        float current_depth = (random_float + float(i)) * step_size;
        if (current_depth >= using_depth) break; // past the hit

        vec4 lookup_pos = vec4(ray.origin + ray.direction * current_depth, 1.0);

        vec4 light_space       = shadow_camera_info.view_proj_mat * lookup_pos;
        vec3 ndc               = light_space.xyz / light_space.w;
        vec2 uv                = ndc.xy * 0.5 + 0.5;
        float t                = ndc.z;
        float shadow_tex_depth = texture(shadow_map_tex, uv).r;

        // If the current point in the atmosphere can be lit
        if (shadow_tex_depth > t) {
            float mist_weight = exp(-lookup_pos.y * 2.0);
            shadow_visibility += mist_weight * step_size; // weight by segment length
        }
    }

    // Convert the path-length sum to the [0,1] range
    float inv_total_len = 1.0 / max(using_depth, 1e-4); // avoid /0
    shadow_visibility *= inv_total_len;

    imageStore(god_ray_output_tex, uvi, vec4(shadow_visibility, 0.0, 0.0, 1.0));
}
