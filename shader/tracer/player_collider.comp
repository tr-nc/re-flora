#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_PlayerColliderInfo {
    vec3 player_pos;
    vec3 camera_front;
}
player_collider_info;

#include "../include/contree_node.glsl"

layout(set = 0, binding = 1) readonly buffer B_ContreeNodeData { ContreeNode data[]; }
contree_node_data;

layout(set = 0, binding = 2) readonly buffer B_ContreeLeafData { uint data[]; }
contree_leaf_data;

layout(set = 0, binding = 3, rg32ui) readonly uniform uimage3D scene_tex;

#define NUM_RING_DISTANCES 8

layout(set = 0, binding = 4) writeonly buffer B_PlayerCollisionResult {
    float ground_distance;
    float ring_distances[NUM_RING_DISTANCES];
}
player_collision_result;

#include "../include/contree_marching.glsl"
#include "../include/core/packer.glsl"
#include "../include/marching_result.glsl"
#include "../include/ray.glsl"

/* ------------------------- unchanged helper functions ---------------------- */
bool scene_hit(inout MarchingResult o_res, vec3 o, vec3 d, ivec3 map_pos, uvec4 scene_tex_read) {
    if (scene_tex_read.x == 0) {
        return false;
    }
    scene_tex_read -= 1;

    ContreeMarchingResult contree_res =
        contree_marching(o, d, map_pos, vec3(1.0), false, scene_tex_read.x, scene_tex_read.y);
    if (contree_res.is_hit) {
        uint voxel_data       = contree_leaf_data.data[contree_res.voxel_addr];
        o_res.is_hit          = true;
        o_res.pos             = contree_res.pos;
        o_res.center_pos      = contree_res.center_pos;
        o_res.is_normal_valid = (voxel_data & (1u << 29)) != 0u;
        o_res.normal          = unpack_normal_v2((voxel_data & 0x1FFFFF00u) >> 8);
        o_res.voxel_type      = voxel_data & 0xFFu;
        o_res.voxel_addr      = contree_res.voxel_addr;
        return true;
    }
    return false;
}
#include "../include/dda_scene_marching.glsl"

MarchingResult general_scene_marching(Ray ray) {
    return dda_scene_marching(ray.origin, ray.direction, ray.inv_direction);
}

#include "../include/core/definitions.glsl"

/* ----------------- tunable constants & unified kernel logic ---------------- */
#define RAY_HALF_KERNAL_SIZE 1     // half size of the square ground-ray kernel
#define RAY_OFFSET (1.0 / 256.0)   // horizontal spacing between ground rays
#define COLLISION_RAY_DISTANCE 2.0 // max range for the non-ground rays

#define KERNEL_DIM (2 * RAY_HALF_KERNAL_SIZE + 1)
#define NUM_GROUND_RAYS (KERNEL_DIM * KERNEL_DIM)

/* total threads = ground rays + ring distances */
#define TOTAL_THREADS (NUM_GROUND_RAYS + NUM_RING_DISTANCES)

/* -------------------------------- shared memory ---------------------------- */
shared float ground_results[KERNEL_DIM][KERNEL_DIM];
shared float ring_collision_distances[NUM_RING_DISTANCES];

/* ----------------------------- helper functions ---------------------------- */
/* Generate ring directions relative to camera front vector */
vec3 get_ring_direction(int ring_index) {
    vec3 flattened_front = normalize(
        vec3(player_collider_info.camera_front.x, 0.0, player_collider_info.camera_front.z));
    vec3 right = normalize(cross(flattened_front, vec3(0.0, 1.0, 0.0)));
    vec3 up    = normalize(cross(right, flattened_front));

    if (ring_index == 0) {
        // First ray shoots forward
        return flattened_front;
    } else {
        // Generate clockwise ring around camera position
        float angle = TWO_PI * float(ring_index - 1) / float(NUM_RING_DISTANCES - 1);
        return normalize(flattened_front * cos(angle) + right * sin(angle));
    }
}

/* inline 2-D Gaussian weight, keeps the kernel auto-consistent with its size */
float gaussian_weight(int x, int y) {
    const float sigma = float(RAY_HALF_KERNAL_SIZE) * 0.5 + 0.5;
    float sigma2      = sigma * sigma;
    return exp(-float(x * x + y * y) / (2.0 * sigma2));
}

void main() {
    int id = int(gl_GlobalInvocationID.x);

    if (id >= TOTAL_THREADS) {
        return;
    }

    if (id < NUM_GROUND_RAYS) {
        int x = id % KERNEL_DIM - RAY_HALF_KERNAL_SIZE;
        int y = id / KERNEL_DIM - RAY_HALF_KERNAL_SIZE;

        vec2 offset     = vec2(float(x), float(y)) * RAY_OFFSET;
        vec3 ray_origin = player_collider_info.player_pos + vec3(offset.x, 0.0, offset.y);

        Ray ray;
        ray.origin        = ray_origin;
        ray.direction     = vec3(0.0, -1.0, 0.0);
        ray.inv_direction = 1.0 / ray.direction;

        MarchingResult res = general_scene_marching(ray);
        ground_results[x + RAY_HALF_KERNAL_SIZE][y + RAY_HALF_KERNAL_SIZE] = res.t;
    } else {
        int ring_index = id - NUM_GROUND_RAYS; // 0 to NUM_RING_DISTANCES-1
        vec3 direction = get_ring_direction(ring_index);

        Ray ray;
        ray.origin        = player_collider_info.player_pos;
        ray.direction     = direction;
        ray.inv_direction = 1.0 / ray.direction;

        MarchingResult res = general_scene_marching(ray);
        float distance = res.is_hit ? min(res.t, COLLISION_RAY_DISTANCE) : COLLISION_RAY_DISTANCE;
        ring_collision_distances[ring_index] = distance;
    }

    barrier();

    if (id == 0) {
        float weighted_sum   = 0.0;
        float sum_of_weights = 0.0;

        for (int i = -RAY_HALF_KERNAL_SIZE; i <= RAY_HALF_KERNAL_SIZE; ++i) {
            for (int j = -RAY_HALF_KERNAL_SIZE; j <= RAY_HALF_KERNAL_SIZE; ++j) {
                float weight = gaussian_weight(i, j);
                weighted_sum +=
                    ground_results[i + RAY_HALF_KERNAL_SIZE][j + RAY_HALF_KERNAL_SIZE] * weight;
                sum_of_weights += weight;
            }
        }

        player_collision_result.ground_distance = weighted_sum / max(sum_of_weights, 1e-8);

        for (int i = 0; i < NUM_RING_DISTANCES; ++i) {
            player_collision_result.ring_distances[i] = ring_collision_distances[i];
        }
    }
}
