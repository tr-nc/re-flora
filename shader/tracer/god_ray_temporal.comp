#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_CameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;

layout(set = 0, binding = 1) uniform U_CameraInfoPrevFrame {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info_prev_frame;

layout(set = 0, binding = 2) uniform U_GodRayTemporalInfo {
    float temporal_alpha;
}
god_ray_temporal_info;

layout(set = 0, binding = 3, r32f) uniform readonly image2D god_ray_output_tex;
layout(set = 0, binding = 4) uniform sampler2D god_ray_output_tex_prev;
layout(set = 0, binding = 5, r32f) uniform writeonly image2D god_ray_output_tex_filtered;
layout(set = 0, binding = 6, r8ui) uniform uimage2D god_ray_hist_len_tex;

#include "../include/ray.glsl"

void main() {
    ivec2 uvi = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(god_ray_output_tex);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    // Current frame god ray value
    float current_value = imageLoad(god_ray_output_tex, uvi).r;

    // Calculate screen UV
    vec2 screen_uv = (vec2(uvi) + vec2(0.5)) / vec2(img_size);

    // Generate ray for current pixel to get a world position for reprojection
    Ray ray = ray_gen(screen_uv, camera_info.view_proj_mat_inv);
    
    // Use a moderate depth for atmospheric effects - not too close, not too far
    float sample_depth = 5.0;
    vec3 world_pos = ray.origin + ray.direction * sample_depth;

    // Reproject to previous frame
    vec4 prev_clip = camera_info_prev_frame.view_proj_mat * vec4(world_pos, 1.0);
    vec3 prev_ndc = prev_clip.xyz / prev_clip.w;
    vec2 prev_uv = prev_ndc.xy * 0.5 + 0.5;

    // Check if the projection is valid (within screen bounds)
    bool valid_reprojection = all(greaterThanEqual(prev_uv, vec2(0.0))) && 
                              all(lessThanEqual(prev_uv, vec2(1.0))) &&
                              prev_clip.w > 0.0; // Also check that we're in front of camera

    float hist_len;
    float filtered_value;

    if (valid_reprojection) {
        // Sample previous frame values
        float prev_value = texture(god_ray_output_tex_prev, prev_uv).r;
        
        // Get previous history length from the closest pixel
        ivec2 prev_uvi = ivec2(prev_uv * vec2(img_size));
        prev_uvi = clamp(prev_uvi, ivec2(0), img_size - 1);
        uint prev_hist = imageLoad(god_ray_hist_len_tex, prev_uvi).x;
        
        // Increment history length, capping at 255
        hist_len = min(255.0, float(prev_hist) + 1.0);
        
        // Calculate adaptive alpha - the more history we have, the more we trust previous frames
        float adaptive_alpha = max(god_ray_temporal_info.temporal_alpha, 1.0 / hist_len);
        
        // Blend current and previous values
        filtered_value = mix(prev_value, current_value, adaptive_alpha);
    } else {
        // Invalid reprojection - use current value only and reset history
        hist_len = 1.0;
        filtered_value = current_value;
    }

    // Store results
    imageStore(god_ray_output_tex_filtered, uvi, vec4(filtered_value, 0.0, 0.0, 1.0));
    imageStore(god_ray_hist_len_tex, uvi, uvec4(uint(hist_len), 0u, 0u, 0u));
}