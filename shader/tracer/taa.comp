/// This is a TAA pass without temporal aliasing. Just to increase the temporal stability

#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_TaaInfo { uint is_taa_enabled; }
taa_info;

layout(set = 0, binding = 1, r11f_g11f_b10f) uniform readonly image2D composited_tex;
layout(set = 0, binding = 2, rg16f) uniform readonly image2D motion_image;
layout(set = 0, binding = 3, r11f_g11f_b10f) uniform writeonly image2D taa_tex;
layout(set = 0, binding = 4, r11f_g11f_b10f) uniform readonly image2D taa_tex_prev;

void get_moments(out vec3 mom1, out vec3 mom2, out vec3 center_color, ivec2 uvi, ivec2 img_size) {
    mom1         = vec3(0.0);
    mom2         = vec3(0.0);
    uint samples = 0u;

    for (int yy = -1; yy <= 1; ++yy) {
        for (int xx = -1; xx <= 1; ++xx) {
            ivec2 p = uvi + ivec2(xx, yy);

            // skip out-of-bounds
            if (any(lessThan(p, ivec2(0))) || any(greaterThanEqual(p, img_size))) {
                continue;
            }

            vec3 color = imageLoad(composited_tex, p).rgb;
            mom1 += color;
            mom2 += color * color;

            if (xx == 0 && yy == 0) {
                center_color = color;
            }
            ++samples;
        }
    }
    float inv_samples = 1.0 / float(samples);
    mom1 *= inv_samples;
    mom2 *= inv_samples;
}

vec2 get_motion(ivec2 uvi) { return imageLoad(motion_image, uvi).xy; }

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(taa_tex);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    if (taa_info.is_taa_enabled == 0) {
        vec3 col = imageLoad(composited_tex, uvi).rgb;
        imageStore(taa_tex, uvi, vec4(col, 0.0));
        return;
    }

    vec3 mom1, mom2, color_center;
    get_moments(mom1, mom2, color_center, uvi, img_size);

    vec2 motion_vec = get_motion(uvi);
    vec2 history_uv = (vec2(uvi) + 0.5 + motion_vec);
    // TODO: maybe use this in temporal filter too?
    // vec3 color_prev = texture(taa_tex_prev, history_uv).rgb;
    vec3 color_prev = imageLoad(taa_tex_prev, ivec2(uvi)).rgb;

    const float VARIANCE_SCALE = 3.0;
    vec3 sigma                 = sqrt(max(vec3(0.0), mom2 - mom1 * mom1));
    vec3 mi                    = mom1 - sigma * VARIANCE_SCALE;
    vec3 ma                    = mom1 + sigma * VARIANCE_SCALE;
    color_prev                 = clamp(color_prev, mi, ma);

    float motion_weight = smoothstep(0.0, 1.0, length(motion_vec));
    float sample_weight = 1.0;
    float pixel_weight  = clamp(max(motion_weight, sample_weight) * 0.2, 0.0, 1.0);

    vec3 final_color = mix(color_prev, color_center, pixel_weight);
    imageStore(taa_tex, uvi, vec4(final_color, 0.0));
}
