#version 460

#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_flags_primitive_culling : enable

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_GuiInput {
    float debug_float;
    uint debug_bool; // bool
    vec3 sun_dir;
    float sun_size;
    vec3 sun_color;
}
gui_input;
layout(set = 0, binding = 1) uniform U_CameraInfo {
    vec4 camera_pos; // w is padding.
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 2) uniform U_EnvInfo { uint frame_serial_idx; }
env_info;
#include "../include/contree_node.glsl"
layout(set = 0, binding = 3) readonly buffer B_ContreeNodeData { ContreeNode data[]; }
contree_node_data;
layout(set = 0, binding = 4) readonly buffer B_ContreeLeafData { uint data[]; }
contree_leaf_data;
layout(set = 0, binding = 5, rg32ui) readonly uniform uimage3D scene_tex;
layout(set = 0, binding = 6, r8) readonly uniform image2DArray scalar_bn;
layout(set = 0, binding = 7, rg8) readonly uniform image2DArray unit_vec2_bn;
layout(set = 0, binding = 8, rgba8) readonly uniform image2DArray unit_vec3_bn;
layout(set = 0, binding = 9, rgba8) readonly uniform image2DArray weighted_cosine_bn;

layout(set = 1, binding = 0) writeonly uniform image2D result_image;

layout(set = 2, binding = 0) uniform accelerationStructureEXT tlas;

#include "../include/contree_marching.glsl"
#include "../include/core/definitions.glsl"
#include "../include/core/packer.glsl"
#include "../include/core/shader_clock.glsl"
#include "../include/core/viridis.glsl"
#include "../include/dda_scene_marching_result.glsl"
#include "../include/ray.glsl"
#include "../include/skylight.glsl"
#include "../include/voxel_color.glsl"

bool scene_hit(inout DdaSceneMarchingResult dda_res, vec3 o, vec3 d, ivec3 map_pos,
               uvec4 scene_tex_read) {
    // see update_scene_tex.comp for encoding part
    if (scene_tex_read.x == 0) {
        return false;
    }
    scene_tex_read -= 1;

    ContreeMarchingResult contree_res =
        contree_marching(o, d, map_pos, vec3(1.0), false, scene_tex_read.x, scene_tex_read.y);
    if (contree_res.is_hit) {
        dda_res.is_hit     = true;
        dda_res.pos        = contree_res.pos;
        dda_res.center_pos = contree_res.center_pos;
        dda_res.normal     = contree_res.normal;
        dda_res.voxel_data = contree_res.voxel_data;
        return true;
    }
    return false;
}

#define SCENE_TEX_NAME scene_tex
#include "../include/dda_scene_marching.glsl"

///

const ivec3 BN_NOISE_TEX_SIZE = ivec3(128, 128, 64);
ivec3 get_seed() {
    return ivec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, env_info.frame_serial_idx) %
           BN_NOISE_TEX_SIZE;
}

// range [0, 1)
float random_float_bn(ivec3 seed) { return imageLoad(scalar_bn, seed).r; }

// range (-1, 1) in 2 components
vec2 random_unit_vec2_bn(ivec3 seed) { return imageLoad(unit_vec2_bn, seed).rg * 2.0 - 1.0; }

// range (-1, 1) in 3 components
vec3 random_unit_vec3_bn(ivec3 seed) { return imageLoad(unit_vec3_bn, seed).rgb * 2.0 - 1.0; }

// range (-1, 1) in 3 components
vec3 random_weighted_cosine_bn(ivec3 seed) {
    return imageLoad(weighted_cosine_bn, seed).rgb * 2.0 - 1.0;
}

// xi.x, xi.y ∈ [-1, +1] assumed uniformly random
// sun_size ∈ [0,1] controls apparent radius of the Sun disk
// sun_dir    unit‐vector pointing to the center of the Sun
vec3 sample_sun_disk(vec2 xi, float sun_size, vec3 sun_dir) {
    // 1) warp xi from [-1,1]→[0,1]²
    float u = 0.5 * (xi.x + 1.0);
    float v = 0.5 * (xi.y + 1.0);

    // 2) uniform‐disk sampling (radius = sun_size)
    float r   = sqrt(u) * sun_size;
    float phi = 2.0 * PI * v;
    float dx  = r * cos(phi);
    float dy  = r * sin(phi);

    // 3) build an ON‐basis (tangent,bitangent) around sun_dir
    vec3 tangent   = normalize(abs(sun_dir.x) < 0.99 ? cross(sun_dir, vec3(1, 0, 0))
                                                     : cross(sun_dir, vec3(0, 1, 0)));
    vec3 bitangent = cross(sun_dir, tangent);

    // 4) offset the center‐ray by (dx,dy) in that plane
    vec3 sampleDir = normalize(sun_dir + dx * tangent + dy * bitangent);

    return sampleDir;
}

///

vec3 get_shadow_ray_color(Ray ray) {
    DdaSceneMarchingResult res_shadow_ray;
    res_shadow_ray = dda_scene_marching(ray.origin, ray.direction, ray.inv_direction);
    if (res_shadow_ray.is_hit) {
        return vec3(0.0);
    }
    return get_sky_color(ray.direction);
}

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(result_image);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    ivec3 seed = get_seed();

    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(camera_info.camera_pos.xyz, screen_uv);

    vec3 vis = vec3(0.0);

    DdaSceneMarchingResult res_primary_ray =
        dda_scene_marching(ray.origin, ray.direction, ray.inv_direction);

    if (res_primary_ray.is_hit) {
        // unpack normal from the packed voxel data (bits 8..28)
        vec3 normal = unpack_normal_v2((res_primary_ray.voxel_data & 0x1FFFFF00u) >> 8);

        uint voxel_type = res_primary_ray.voxel_data & 0xFFu;
        vec3 albedo     = voxel_color_by_type_unorm(voxel_type);

        vec3 shadow_ray_col = vec3(0.0);

        //
        vec2 rand    = random_unit_vec2_bn(seed);
        vec3 sun_dir = sample_sun_disk(rand, gui_input.sun_size, gui_input.sun_dir);

        Ray shadow_ray;
        shadow_ray.direction     = sun_dir;
        shadow_ray.inv_direction = vec3(1.0) / shadow_ray.direction;

        // gives more accurate shadow
        vec2 t                = slabs(vec3(-1.0), vec3(1.0), vec3(0.0), 1.0 / normal);
        float half_voxel_size = 1.0 / 512.0; // assuming the voxel size is 1/512
        // 0.004 is experimental to maintain a good shadow quality
        vec3 march_extent = normal * (t.y * half_voxel_size + 0.005);

        shadow_ray.origin = res_primary_ray.center_pos + march_extent;

        if (dot(shadow_ray.direction, normal) > 0.0) {
            shadow_ray_col = get_shadow_ray_color(shadow_ray) * dot(shadow_ray.direction, normal);
        }
        vis = gui_input.sun_color * albedo * shadow_ray_col * 0.01;
    } else {
        vis = get_sky_color(ray.direction);
    }

    //

    imageStore(result_image, uvi, vec4(vis, 1.0));
}
