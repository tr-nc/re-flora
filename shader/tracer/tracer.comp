#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_GuiInput { float debug_float; }
gui_input;
layout(set = 0, binding = 1) uniform U_CameraInfo {
    vec4 camera_pos; // w is padding.
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 2) uniform U_EnvInfo { uint time_stamp; }
env_info;
layout(set = 0, binding = 3) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 4) writeonly uniform image2D result_image;

#include "../include/vertex_index_attribute.glsl"
layout(set = 0, binding = 5) readonly buffer B_Vertices { Vertex data[]; }
vertices;
layout(set = 0, binding = 6) readonly buffer B_Indices { Index data[]; }
indices;

#include "../include/core/packer.glsl"
#include "../include/ray.glsl"
#include "../include/voxel_color.glsl"
#include "../include/voxel_type.glsl"

void get_voxel_type_normal(out uint o_voxel_type, out vec3 o_normal, out bool o_is_normal_valid,
                           uint compressed_voxel_type_and_normal) {
    o_voxel_type      = compressed_voxel_type_and_normal & 0xFF;
    o_normal          = unpack_normal_v2((compressed_voxel_type_and_normal & 0x1FFFFF00u) >> 8);
    o_is_normal_valid = (compressed_voxel_type_and_normal & 0x20000000u) != 0;
}

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(result_image);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(camera_info.camera_pos.xyz, screen_uv);

    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, tlas,
                          gl_RayFlagsOpaqueEXT, // skip “transparent” triangles
                          0xFF,                 // instance mask
                          ray.origin,
                          0.001, // bias off your surface
                          ray.direction, 10000.0);

    // notice: do not change the content of this loop, this is not shader logic at all.
    while (rayQueryProceedEXT(rayQuery)) {
        if (rayQueryGetIntersectionTypeEXT(rayQuery, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {
            // “commit” it; this tells the driver “yes, I want
            // you to consider this for the nearest‐hit test”
            rayQueryConfirmIntersectionEXT(rayQuery);
        }
    }

    // after traversal, ask whether we actually committed a hit
    bool hit = (rayQueryGetIntersectionTypeEXT(rayQuery, true) ==
                gl_RayQueryCommittedIntersectionTriangleEXT);

    vec3 ray_color = vec3(0.0);
    if (hit) {
        float t = rayQueryGetIntersectionTEXT(rayQuery, true);
        vec3 insect_pos = ray.origin + ray.direction * t;

        // the triangle index
        int primitive_index = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
        // ray_color = vec3(float(idx) / 1000.0);
        uint vert_index = indices.data[primitive_index * 3].index;
        Vertex vert     = vertices.data[vert_index];
        vec3 normal;
        bool is_normal_valid;
        uint voxel_type;
        get_voxel_type_normal(voxel_type, normal, is_normal_valid,
                              vert.compressed_voxel_type_and_normal);
        ray_color = normal * 0.5 + 0.5;

        ray_color = vec3(insect_pos);
    }
    imageStore(result_image, uvi, vec4(ray_color, 1.0));
}
