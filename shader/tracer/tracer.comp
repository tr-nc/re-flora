#version 460

#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_flags_primitive_culling : enable

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_GuiInput { float debug_float; }
gui_input;
layout(set = 0, binding = 1) uniform U_CameraInfo {
    vec4 camera_pos; // w is padding.
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 2) uniform U_EnvInfo { uint time_stamp; }
env_info;
layout(set = 0, binding = 3) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 4) writeonly uniform image2D result_image;

#include "../include/core/packer.glsl"
#include "../include/core/shader_time.glsl"
#include "../include/core/viridis.glsl"
#include "../include/ray.glsl"
#include "../include/voxel_color.glsl"
#include "../include/voxel_type.glsl"

// intersects if: t_min < t_max && t_max > 0.0
// t_min is the first intersection point, t_max is the last intersection point
// t_min might be negative, which means the ray starts inside the box
vec2 slabs(vec3 p0, vec3 p1, vec3 o, vec3 inv_d) {
    vec3 t0 = (p0 - o) * inv_d;
    vec3 t1 = (p1 - o) * inv_d;

    vec3 temp = t0;
    t0 = min(temp, t1), t1 = max(temp, t1);

    float t_min = max(max(t0.x, t0.y), t0.z);
    float t_max = min(min(t1.x, t1.y), t1.z);

    return vec2(t_min, t_max);
}

void get_voxel_type_normal(out uint o_voxel_type, out vec3 o_normal, out bool o_is_normal_valid,
                           uint compressed_voxel_type_and_normal) {
    o_voxel_type      = compressed_voxel_type_and_normal & 0xFF;
    o_normal          = unpack_normal_v2((compressed_voxel_type_and_normal & 0x1FFFFF00u) >> 8);
    o_is_normal_valid = (compressed_voxel_type_and_normal & 0x20000000u) != 0;
}

const float EPSILON = 1e-4;
uint dda_svo_marching(ivec3 visible_chunk_dim, vec3 o, vec3 d, vec3 inv_d) {
    vec3 min_bound = vec3(0.0);
    vec3 max_bound = vec3(visible_chunk_dim);

    vec2 t = slabs(min_bound, max_bound, o, inv_d);
    if (t.x > t.y || t.y < 0.0) {
        return 0;
    }

    float march_extent = max(t.x, 0.0) + EPSILON;
    vec3 pos           = o + march_extent * d;

    float t_max     = 0;
    uint iter_count = 0;
    while (iter_count++ < 10000) {
        vec3 cell_min  = floor(pos);
        vec3 cell_size = vec3(1.0);

        vec3 side_pos  = cell_min + step(0.0, d) * cell_size;
        vec3 side_dist = (side_pos - o) * inv_d;

        t_max = min(min(side_dist.x, side_dist.y), side_dist.z) + EPSILON;

        pos = o + t_max * d;

        if (t_max > t.y) {
            break;
        }
    }
    return iter_count;
}

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(result_image);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(camera_info.camera_pos.xyz, screen_uv);

    uint hit_count = 0;

    uvec2 start_time = get_current_time();
    hit_count = dda_svo_marching(ivec3(200, 8, 200), ray.origin, ray.direction, ray.inv_direction);
    uvec2 end_time = get_current_time();

    float delta_time = get_delta_time(start_time, end_time);
    vec3 time_vis    = inferno_quintic(1.0 - exp(-float(delta_time)));
    vec3 vis         = inferno_quintic(1.0 - exp(-float(hit_count) * 0.1));
    // vis              = mix(vis, time_vis, 0.5);

    imageStore(result_image, uvi, vec4(vis, 1.0));
}
