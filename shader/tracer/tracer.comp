#version 450

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_GuiInput { float debug_float; }
gui_input;
layout(set = 0, binding = 1) uniform U_CameraInfo {
    vec4 camera_pos; // w is padding.
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 2) uniform U_SceneInfo { uvec3 visible_chunk_dim; }
scene_info;
layout(set = 0, binding = 7) uniform U_EnvInfo { uint time_stamp; }
env_info;
layout(set = 0, binding = 3) buffer B_OctreeData { uint data[]; }
octree_data;
#include "../include/bvh.glsl"
layout(set = 0, binding = 6) readonly buffer B_BvhNodes { BvhNode data[]; }
bvh_nodes;
layout(set = 0, binding = 4) writeonly uniform image2D result_image;
layout(set = 0, binding = 5, r8ui) readonly uniform uimage3D octree_offset_atlas_tex;

#include "../include/core/aabb.glsl"
#include "../include/core/color.glsl"
#include "../include/dda_svo_marching.glsl"
#include "../include/ray.glsl"
#include "../include/voxel_types.glsl"

///

#ifndef BVH_SVO_MARCHING_GLSL
#define BVH_SVO_MARCHING_GLSL

#include "../include/bvh.glsl"
#include "../include/core/aabb.glsl"
#include "../include/svo_marching.glsl"

struct BvhSvoMarchingResult {
    bool is_hit;
    uint total_iter; // all iterations for all svos
    SvoMarchingResult hit_svo_result;
};

struct StackInfo {
    uint node_index;
    uint depth;
};

// -----------------------------------------------------------------------------
// BVH traversal that returns the NEAREST real surface hit.
// -----------------------------------------------------------------------------
BvhSvoMarchingResult traverse_bvh(Ray ray) {
    BvhSvoMarchingResult res;
    res.is_hit     = false;
    res.total_iter = 0u; // keep a running total for statistics only

    float best_hit_depth = 1e30; // +INF : nothing hit yet

    // Small explicit stack ----------------------------------------------------
    const uint STACK_SIZE = 100u;
    StackInfo stack[STACK_SIZE];
    uint sp = 0u;

    stack[sp++] = StackInfo(0u, 0u); // push root

    while (sp > 0u) {
        // pop
        StackInfo si = stack[--sp];
        uint nodeIdx = si.node_index;

        // ---- AABB test ------------------------------------------------------
        BvhNode node = bvh_nodes.data[nodeIdx];

        float t_near, t_far;
        if (!intersect_aabb(t_near, t_far, ray.origin, ray.inv_direction, node.aabb_min,
                            node.aabb_max))
            continue; // completely miss → skip

        // no need to look farther than a hit we already have
        if (t_near > best_hit_depth) continue;

        // ---- Leaf -----------------------------------------------------------
        if (is_leaf(node)) {
            uint octree_offset = fetch_data(node);

            vec3 offset = node.aabb_min;
            vec3 scale  = node.aabb_max - node.aabb_min;

            SvoMarchingResult r =
                svo_marching(ray.origin, ray.direction, offset, scale, octree_offset);

            res.total_iter += r.iter;

            // keep the *nearest* real hit
            if (r.is_hit && r.t < best_hit_depth) {
                res.is_hit         = true;
                res.hit_svo_result = r;
                best_hit_depth     = r.t;
            }
            continue;
        }

        // ---- Internal node --------------------------------------------------
        // children are stored *consecutively*: left = node.left, right = left+1
        uint leftChild  = node.offset;
        uint rightChild = node.offset + 1u;

        // We still want to visit the nearer child first.
        float t_near_l = 1e30, t_near_r = 1e30, dummy_far;
        bool hitL =
            intersect_aabb(t_near_l, dummy_far, ray.origin, ray.inv_direction,
                           bvh_nodes.data[leftChild].aabb_min, bvh_nodes.data[leftChild].aabb_max);

        bool hitR = intersect_aabb(t_near_r, dummy_far, ray.origin, ray.inv_direction,
                                   bvh_nodes.data[rightChild].aabb_min,
                                   bvh_nodes.data[rightChild].aabb_max);

        // push the far child first (LIFO → near processed first)
        if (hitL && hitR) {
            uint first    = (t_near_l < t_near_r) ? leftChild : rightChild;
            uint second   = (t_near_l < t_near_r) ? rightChild : leftChild;
            float tFirst  = min(t_near_l, t_near_r);
            float tSecond = max(t_near_l, t_near_r);

            if (tSecond < best_hit_depth && sp < STACK_SIZE)
                stack[sp++] = StackInfo(second, si.depth + 1u);
            if (tFirst < best_hit_depth && sp < STACK_SIZE)
                stack[sp++] = StackInfo(first, si.depth + 1u);
        } else if (hitL && t_near_l < best_hit_depth && sp < STACK_SIZE) {
            stack[sp++] = StackInfo(leftChild, si.depth + 1u);
        } else if (hitR && t_near_r < best_hit_depth && sp < STACK_SIZE) {
            stack[sp++] = StackInfo(rightChild, si.depth + 1u);
        }
    }

    return res;
}

#endif // BVH_SVO_MARCHING_GLSL

///

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(result_image);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(camera_info.camera_pos.xyz, screen_uv);

    DdaSvoMarchingResult dda_svo_marching_result =
        dda_svo_marching(ivec3(scene_info.visible_chunk_dim), ray.origin, ray.direction);

    vec3 ray_color = vec3(0.0);
    float depth    = 1e30; // +INF : nothing hit yet

    if (dda_svo_marching_result.is_hit) {
        vec3 normal_color;
        if (dda_svo_marching_result.hit_svo_result.is_normal_valid) {
            normal_color = dda_svo_marching_result.hit_svo_result.normal * 0.5 + 0.5;
            normal_color *= 0.2;
        } else {
            normal_color = vec3(1.0, 1.0, 1.0);
        }

        vec3 voxel_color = srgb_to_linear(
            voxel_srgb_color_by_type(dda_svo_marching_result.hit_svo_result.voxel_type));

        ray_color = mix(voxel_color, normal_color, 0.5);
        depth     = dda_svo_marching_result.hit_svo_result.t;
    }

    BvhSvoMarchingResult bvh_svo_marching_result = traverse_bvh(ray);
    if (bvh_svo_marching_result.is_hit && depth > bvh_svo_marching_result.hit_svo_result.t) {
        if (bvh_svo_marching_result.hit_svo_result.is_normal_valid) {
            ray_color = bvh_svo_marching_result.hit_svo_result.normal * 0.5 + 0.5;
        } else {
            ray_color = vec3(1.0, 1.0, 1.0);
        }
        depth = bvh_svo_marching_result.hit_svo_result.t;
    }

    imageStore(result_image, uvi, vec4(ray_color, 1.0));
}
