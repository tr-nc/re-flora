#version 460

#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_flags_primitive_culling : enable

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_GuiInput {
    float debug_float;
    uint debug_bool; // bool
}
gui_input;
layout(set = 0, binding = 1) uniform U_CameraInfo {
    vec4 camera_pos; // w is padding.
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 2) uniform U_EnvInfo { uint time_stamp; }
env_info;
#include "../include/contree_node.glsl"
layout(set = 0, binding = 3) readonly buffer B_ContreeNodeData { ContreeNode data[]; }
contree_node_data;
layout(set = 0, binding = 4) readonly buffer B_ContreeLeafData { uint data[]; }
contree_leaf_data;
layout(set = 0, binding = 5, rg32ui) readonly uniform uimage3D scene_tex;

layout(set = 1, binding = 0) writeonly uniform image2D result_image;

layout(set = 2, binding = 0) uniform accelerationStructureEXT tlas;

#include "../include/contree_marching.glsl"
#include "../include/core/packer.glsl"
#include "../include/core/shader_clock.glsl"
#include "../include/core/viridis.glsl"
#include "../include/dda_scene_marching_result.glsl"
#include "../include/grass_color.glsl"
#include "../include/grass_type.glsl"
#include "../include/ray.glsl"

bool scene_hit(inout DdaSceneMarchingResult dda_res, vec3 o, vec3 d, ivec3 map_pos,
               uvec4 scene_tex_read) {
    // see update_scene_tex.comp for the encoding part
    if (scene_tex_read.x == 0) {
        return false;
    }
    scene_tex_read -= 1;

    ContreeMarchingResult contree_res =
        contree_marching(o, d, map_pos, vec3(1.0), false, scene_tex_read.x, scene_tex_read.y);
    if (contree_res.is_hit) {
        dda_res.is_hit     = true;
        dda_res.pos        = contree_res.pos;
        dda_res.normal     = contree_res.normal;
        dda_res.voxel_data = contree_res.voxel_data;
        return true;
    }
    return false;
}

#define SCENE_TEX_NAME scene_tex
#include "../include/dda_scene_marching.glsl"

///

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(result_image);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(camera_info.camera_pos.xyz, screen_uv);

    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, tlas,
                          gl_RayFlagsOpaqueEXT, // skip “transparent” triangles
                          0xFF,                 // instance mask
                          ray.origin,
                          0.001, // bias off your surface
                          ray.direction, 10000.0);

    // march through *every* candidate
    while (rayQueryProceedEXT(rayQuery)) {
        if (rayQueryGetIntersectionTypeEXT(rayQuery, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {
            // “commit” it; this tells the driver “yes, I want
            // you to consider this for the nearest‐hit test”
            rayQueryConfirmIntersectionEXT(rayQuery);
        }
    }

    vec3 vis = vec3(0.0);

    const vec3 SKYBOX_COLOR = vec3(0.5, 0.7, 1.0);

    // after traversal, ask whether we actually committed a hit
    bool hit_grass = (rayQueryGetIntersectionTypeEXT(rayQuery, true) ==
                      gl_RayQueryCommittedIntersectionTriangleEXT);
    float t_grass  = rayQueryGetIntersectionTEXT(rayQuery, true);

    DdaSceneMarchingResult res = dda_scene_marching(ray.origin, ray.direction, ray.inv_direction);

    if (!hit_grass && !res.is_hit) {
        vis = SKYBOX_COLOR;
    } else {
        if (t_grass < res.t) {
            vis = grass_color_by_type_unorm(GRASS_TYPE_NORMAL);
        } else {
            vec3 normal = unpack_normal_v2((res.voxel_data & 0x1FFFFF00u) >> 8);
            normal = normal * 0.5 + 0.5; // convert to [0..1] range
            vis         = res.is_hit ? normal : vec3(0.0);
        }
    }

    imageStore(result_image, uvi, vec4(vis, 1.0));
}
