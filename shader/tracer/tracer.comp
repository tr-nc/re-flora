#version 460

#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_flags_primitive_culling : enable

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_GuiInput { float debug_float; }
gui_input;
layout(set = 0, binding = 1) uniform U_CameraInfo {
    vec4 camera_pos; // w is padding.
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 2) uniform U_EnvInfo { uint time_stamp; }
env_info;
layout(set = 0, binding = 3) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 4) writeonly uniform image2D result_image;

#include "../include/core/packer.glsl"
#include "../include/core/shader_time.glsl"
#include "../include/core/viridis.glsl"
#include "../include/ray.glsl"
#include "../include/voxel_color.glsl"
#include "../include/voxel_type.glsl"

bool slabs(vec3 p0, vec3 p1, vec3 rayOrigin, vec3 invRaydir) {
    // compute t‐values where the ray crosses the x,y,z slabs
    vec3 t0 = (p0 - rayOrigin) * invRaydir;
    vec3 t1 = (p1 - rayOrigin) * invRaydir;

    // for each axis, tmin is the nearer crossing, tmax the farther
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    // find the largest of the three enters, and the smallest of the three exits
    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit  = min(min(tmax.x, tmax.y), tmax.z);

    // intersection occurs if the ray “enters” before it “exits”
    return tEnter <= tExit && tExit >= 0.0;
}

void get_voxel_type_normal(out uint o_voxel_type, out vec3 o_normal, out bool o_is_normal_valid,
                           uint compressed_voxel_type_and_normal) {
    o_voxel_type      = compressed_voxel_type_and_normal & 0xFF;
    o_normal          = unpack_normal_v2((compressed_voxel_type_and_normal & 0x1FFFFF00u) >> 8);
    o_is_normal_valid = (compressed_voxel_type_and_normal & 0x20000000u) != 0;
}

bool _in_chunk_range(ivec3 pos, ivec3 visible_chunk_dim) {
    return all(greaterThanEqual(pos, ivec3(0))) && all(lessThan(pos, visible_chunk_dim));
}

bool _has_chunk(ivec3 chunk_idx) { return true; }

// this function if used for continuous raymarching, where we need to save the last hit chunk
bool dda_marching_with_save(out ivec3 o_chunk_idx, inout ivec3 map_pos, inout vec3 side_dist,
                            inout bool entered_visible_region, inout uint it,
                            ivec3 visible_chunk_dim, vec3 delta_dist, ivec3 ray_step) {
    bvec3 mask;
    while (it++ < 10240) {
        mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
        side_dist += vec3(mask) * delta_dist;

        o_chunk_idx = map_pos;
        map_pos += ivec3(vec3(mask)) * ray_step;

        if (_in_chunk_range(o_chunk_idx, visible_chunk_dim)) {
            entered_visible_region = true;
            if (_has_chunk(o_chunk_idx)) {
                return true;
            }
        }
        // went outside the outer bounding box
        else if (entered_visible_region) {
            return false;
        }
    }
    return false;
}

uint dda_svo_marching(ivec3 visible_chunk_dim, vec3 o, vec3 d, vec3 inv_d) {
    if (!slabs(vec3(0.0), vec3(visible_chunk_dim), o, inv_d)) {
        return 0;
    }

    d = max(abs(d), vec3(1e-5)) * (step(0.0, d) * 2.0 - 1.0);

    ivec3 map_pos         = ivec3(floor(o));
    const vec3 delta_dist = 1.0 / abs(d);
    const ivec3 ray_step  = ivec3(sign(d));
    vec3 side_dist        = (((sign(d) * 0.5) + 0.5) + sign(d) * (vec3(map_pos) - o)) * delta_dist;
    bool entered_visible_region = false;
    uint dda_iteration          = 0;

    ivec3 chunk_idx;

    uint iter_count = 0;
    while (dda_marching_with_save(chunk_idx, map_pos, side_dist, entered_visible_region,
                                  dda_iteration, visible_chunk_dim, delta_dist, ray_step)) {
        iter_count++;
    }
    return iter_count;
}

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(result_image);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(camera_info.camera_pos.xyz, screen_uv);

    uint hit_count = 0;

    // 227 for full cube
    // 390 for half cube
    // 500 for a single blas
    // 3000 for dda slab...........

    // hardware rtx
    // rayQueryEXT rq;
    // rayQueryInitializeEXT(rq, tlas, gl_RayFlagsNoneEXT, 0xFF, ray.origin, 0.001, ray.direction,
    //                       1e4);
    // while (rayQueryProceedEXT(rq)) {
    //     if (rayQueryGetIntersectionTypeEXT(rq, /*committed=*/false) ==
    //         gl_RayQueryCandidateIntersectionTriangleEXT) {
    //         hit_count++;
    //     }
    // }

    uvec2 start_time = get_current_time();

    // slab dda
    hit_count = dda_svo_marching(ivec3(16, 8, 16), ray.origin, ray.direction, ray.inv_direction);

    uvec2 end_time = get_current_time();

    float delta_time = get_delta_time(start_time, end_time);
    vec3 time_vis    = inferno_quintic(1.0 - exp(-float(delta_time)));
    vec3 vis         = inferno_quintic(1.0 - exp(-float(hit_count) * 0.1));
    // vis        = mix(vis, time_vis, 0.5);

    imageStore(result_image, uvi, vec4(vis, 1.0));
}
