#version 450

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_GuiInput { float debug_float; }
gui_input;
layout(set = 0, binding = 1) uniform U_CameraInfo {
    vec4 camera_pos; // w is padding.
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 2) uniform U_SceneInfo { uvec3 visible_chunk_dim; }
scene_info;
layout(set = 0, binding = 7) uniform U_EnvInfo { uint time_stamp; }
env_info;
layout(set = 0, binding = 3) buffer B_OctreeData { uint data[]; }
octree_data;
#include "../include/bvh.glsl"
layout(set = 0, binding = 6) readonly buffer B_BvhNodes { BvhNode data[]; }
bvh_nodes;
layout(set = 0, binding = 4) writeonly uniform image2D result_image;
layout(set = 0, binding = 5, r8ui) readonly uniform uimage3D octree_offset_atlas_tex;

#include "../include/bvh_svo_marching.glsl"
#include "../include/core/aabb.glsl"
#include "../include/dda_svo_marching.glsl"
#include "../include/ray.glsl"
#include "../include/voxel_color.glsl"
#include "../include/voxel_type.glsl"

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(result_image);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(camera_info.camera_pos.xyz, screen_uv);

    DdaSvoMarchingResult dda_svo_marching_result =
        dda_svo_marching(ivec3(scene_info.visible_chunk_dim), ray.origin, ray.direction);

    vec3 ray_color = vec3(0.0);
    float depth    = 1e30; // +INF : nothing hit yet

    if (dda_svo_marching_result.is_hit) {
        vec3 normal_color;
        if (dda_svo_marching_result.hit_svo_result.is_normal_valid) {
            normal_color = dda_svo_marching_result.hit_svo_result.normal * 0.5 + 0.5;
            normal_color *= 0.1;
        } else {
            normal_color = vec3(1.0, 1.0, 1.0);
        }

        vec3 voxel_color =
            voxel_color_by_type_unorm(dda_svo_marching_result.hit_svo_result.voxel_type);

        ray_color = mix(voxel_color, normal_color, 0.5);
        depth     = dda_svo_marching_result.hit_svo_result.t;
    }

    BvhSvoMarchingResult bvh_svo_marching_result =
        traverse_bvh(ray.origin, ray.direction, ray.inv_direction);

    if (bvh_svo_marching_result.is_hit && depth > bvh_svo_marching_result.hit_svo_result.t) {
        vec3 voxel_color =
            voxel_color_by_type_unorm(bvh_svo_marching_result.hit_svo_result.voxel_type);
        ray_color = voxel_color;
        depth     = bvh_svo_marching_result.hit_svo_result.t;
    }

    imageStore(result_image, uvi, vec4(ray_color, 1.0));
}
