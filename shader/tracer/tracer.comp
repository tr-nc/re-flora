#version 450

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_GuiInput { float debug_float; }
gui_input;
layout(set = 0, binding = 1) uniform U_CameraInfo {
    vec4 camera_pos; // w is padding.
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 2) uniform U_SceneInfo { uvec3 visible_chunk_dim; }
scene_info;
layout(set = 0, binding = 7) uniform U_EnvInfo { uint time_stamp; }
env_info;
layout(set = 0, binding = 3) buffer B_OctreeData { uint data[]; }
octree_data;
#include "../include/bvh.glsl"
layout(set = 0, binding = 6) readonly buffer B_BvhNodes { BvhNode data[]; }
bvh_nodes;
layout(set = 0, binding = 4) writeonly uniform image2D result_image;
layout(set = 0, binding = 5, r8ui) readonly uniform uimage3D octree_offset_atlas_tex;

#include "../include/core/aabb.glsl"
#include "../include/dda_svo_marching.glsl"
#include "../include/ray.glsl"

///

#ifndef BVH_SVO_MARCHING_GLSL
#define BVH_SVO_MARCHING_GLSL

#include "../include/bvh.glsl"
#include "../include/core/aabb.glsl"
#include "../include/svo_marching.glsl"

struct BvhSvoMarchingResult {
    bool is_hit;
    uint total_iter; // all iterations for all svos
    SvoMarchingResult hit_svo_result;
};

struct StackInfo {
    uint node_index;
    uint depth;
};

/// Traverses the BVH tree to find the closest intersection of the ray.
BvhSvoMarchingResult traverse_bvh(Ray ray) {
    BvhSvoMarchingResult res;
    res.is_hit     = false;
    res.total_iter = 0;

    // best_hit_depth holds the current closest inner test hit (if any).
    float best_hit_depth = 1e30;
    vec3 final_color     = vec3(0.0);
    // a fixed-size stack storing node index and its corresponding depth in the
    // tree
    const uint STACK_SIZE = 100;
    StackInfo stack[STACK_SIZE];
    uint stack_ptr = 0;

    // push the root node with depth 0
    stack[stack_ptr++] = StackInfo(0, 0);

    while (stack_ptr > 0) {
        // pop a node from the stack
        stack_ptr--;
        StackInfo cur_info = stack[stack_ptr];
        uint node_index    = cur_info.node_index;
        uint node_depth    = cur_info.depth; // debug: you now have the depth info here

        BvhNode node = bvh_nodes.data[node_index];

        float t_near, t_far;
        // if the ray does not hit this node's AABB, skip it
        if (!intersect_aabb(t_near, t_far, ray.origin, ray.inv_direction, node.aabb_min,
                            node.aabb_max)) {
            continue;
        }

        // early-out: skip if the node is farther than an already found hit
        if (t_near > best_hit_depth) {
            continue;
        }

        // perform inner test at leaf nodes
        if (is_leaf(node)) {
            uint octree_buffer_offset = fetch_data(node);

            // TODO: apply scaling too
            SvoMarchingResult svo_marching_result =
                svo_marching(ray.origin, ray.direction, node.aabb_min, octree_buffer_offset);
            res.total_iter += svo_marching_result.iter;
            if (svo_marching_result.is_hit && svo_marching_result.t < best_hit_depth) {
                // TODO: see if further operation is needed
                best_hit_depth = svo_marching_result.t;
                break;
            }
            continue;
        }

        // process internal nodes by testing left and right children
        float t_near_left  = 1e30;
        float t_near_right = 1e30;
        bool hit_left      = false;
        bool hit_right     = false;
        float dummy_far;

        hit_left  = intersect_aabb(t_near_left, dummy_far, ray.origin, ray.inv_direction,
                                   bvh_nodes.data[node.offset].aabb_min,
                                   bvh_nodes.data[node.offset].aabb_max);
        hit_right = intersect_aabb(t_near_right, dummy_far, ray.origin, ray.inv_direction,
                                   bvh_nodes.data[node.offset + 1].aabb_min,
                                   bvh_nodes.data[node.offset + 1].aabb_max);

        // push the children in order from farthest to nearest so that the nearest
        // is processed first (LIFO)
        if (hit_left && hit_right) {
            bool left_first  = t_near_left < t_near_right; // determine which intersection is closer
            float first_near = left_first ? t_near_left : t_near_right;
            float second_near = left_first ? t_near_right : t_near_left;
            uint first_child  = left_first ? node.offset : (node.offset + 1);
            uint second_child = left_first ? (node.offset + 1) : node.offset;

            if (second_near < best_hit_depth)
                stack[stack_ptr++] = StackInfo(second_child, node_depth + 1);
            if (first_near < best_hit_depth)
                stack[stack_ptr++] = StackInfo(first_child, node_depth + 1);

            continue;
        }
        if (hit_left && t_near_left < best_hit_depth) {
            stack[stack_ptr++] = StackInfo(node.offset, node_depth + 1);
            continue;
        }
        if (hit_right && t_near_right < best_hit_depth) {
            stack[stack_ptr++] = StackInfo(node.offset + 1, node_depth + 1);
            continue;
        }
    }
    return res;
}

#endif // BVH_SVO_MARCHING_GLSL

///

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(result_image);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(camera_info.camera_pos.xyz, screen_uv);

    DdaSvoMarchingResult dda_svo_marching_result =
        dda_svo_marching(ivec3(scene_info.visible_chunk_dim), ray.origin, ray.direction);

    vec3 voxel_color = vec3(0.0);
    if (dda_svo_marching_result.is_hit) {
        voxel_color = dda_svo_marching_result.hit_svo_result.normal * 0.5 + 0.5;
        voxel_color *= 0.2;
        voxel_color = dda_svo_marching_result.hit_svo_result.is_normal_valid ? voxel_color
                                                                             : vec3(1.0, 1.0, 1.0);
    }

    BvhSvoMarchingResult bvh_svo_marching_result = traverse_bvh(ray);
    voxel_color += vec3(float(bvh_svo_marching_result.total_iter)) * 0.1;

    vec4 out_color = vec4(0.0);
    out_color      = vec4(voxel_color, 1.0);

    imageStore(result_image, uvi, out_color);
}
