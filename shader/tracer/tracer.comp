#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_GuiInput {
    float debug_float;
    uint debug_bool;
    uint debug_uint;
}
gui_input;
layout(set = 0, binding = 1) uniform U_SkyInfo {
    vec3 sun_dir;
    float sun_size;
    vec3 sun_color;
    float sun_luminance;
    vec3 sky_color;
    vec3 sky_bottom_color;
    vec3 debug_color_1;
    vec3 debug_color_2;
}
sky_info;
layout(set = 0, binding = 2) uniform U_CameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info;
layout(set = 0, binding = 3) uniform U_CameraInfoPrevFrame {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
camera_info_prev_frame;
layout(set = 0, binding = 4) uniform U_ShadowCameraInfo {
    vec4 pos;
    mat4 view_mat;
    mat4 view_mat_inv;
    mat4 proj_mat;
    mat4 proj_mat_inv;
    mat4 view_proj_mat;
    mat4 view_proj_mat_inv;
}
shadow_camera_info;
layout(set = 0, binding = 5) uniform U_EnvInfo { uint frame_serial_idx; }
env_info;
#include "../include/contree_node.glsl"
layout(set = 0, binding = 6) readonly buffer B_ContreeNodeData { ContreeNode data[]; }
contree_node_data;
layout(set = 0, binding = 7) readonly buffer B_ContreeLeafData { uint data[]; }
contree_leaf_data;
layout(set = 0, binding = 8, rg32ui) readonly uniform uimage3D scene_tex;
layout(set = 0, binding = 9) uniform sampler2D shadow_map_tex;

layout(set = 1, binding = 0, r32ui) writeonly uniform uimage2D compute_output_tex;
layout(set = 1, binding = 1, r32f) writeonly uniform image2D compute_depth_tex;

layout(set = 2, binding = 0, r8) readonly uniform image2DArray scalar_bn;
layout(set = 2, binding = 1, rg8) readonly uniform image2DArray unit_vec2_bn;
layout(set = 2, binding = 2, rgba8) readonly uniform image2DArray unit_vec3_bn;
layout(set = 2, binding = 3, rgba8) readonly uniform image2DArray weighted_cosine_bn;
layout(set = 2, binding = 4, rgba8) readonly uniform image2DArray fast_unit_vec3_bn;
layout(set = 2, binding = 5, rgba8) readonly uniform image2DArray fast_weighted_cosine_bn;
#include "../include/noise_tex.glsl"

layout(set = 3, binding = 0, r32ui) uniform uimage2D denoiser_normal_tex;
layout(set = 3, binding = 1, r32ui) uniform uimage2D denoiser_normal_tex_prev;
layout(set = 3, binding = 2, rgba32f) uniform image2D denoiser_position_tex;
layout(set = 3, binding = 3, rgba32f) uniform image2D denoiser_position_tex_prev;
layout(set = 3, binding = 4, r32ui) uniform uimage2D denoiser_vox_id_tex;
layout(set = 3, binding = 5, r32ui) uniform uimage2D denoiser_vox_id_tex_prev;
layout(set = 3, binding = 6, r32ui) uniform uimage2D denoiser_accumed_tex;
layout(set = 3, binding = 7, r32ui) uniform uimage2D denoiser_accumed_tex_prev;
layout(set = 3, binding = 8, rg16f) uniform image2D denoiser_motion_tex;
layout(set = 3, binding = 9, r8ui) uniform uimage2D denoiser_temporal_hist_len_tex;
layout(set = 3, binding = 10, r8ui) uniform uimage2D denoiser_hit_tex;
layout(set = 3, binding = 11, r11f_g11f_b10f) uniform image2D denoiser_spatial_ping_tex;
layout(set = 3, binding = 12, r11f_g11f_b10f) uniform image2D denoiser_spatial_pong_tex;

#include "../include/contree_marching.glsl"
#include "../include/core/definitions.glsl"
#include "../include/core/packer.glsl"
#include "../include/core/shader_clock.glsl"
#include "../include/core/viridis.glsl"
#include "../include/marching_result.glsl"
#include "../include/pcss.glsl"
#include "../include/ray.glsl"
#include "../include/skylight.glsl"
#include "../include/voxel_registry.glsl"

bool scene_hit(inout MarchingResult o_res, vec3 o, vec3 d, ivec3 map_pos, uvec4 scene_tex_read) {
    // see update_scene_tex.comp for encoding part
    if (scene_tex_read.x == 0) {
        return false;
    }
    scene_tex_read -= 1;

    ContreeMarchingResult contree_res =
        contree_marching(o, d, map_pos, vec3(1.0), false, scene_tex_read.x, scene_tex_read.y);
    if (contree_res.is_hit) {
        uint voxel_data       = contree_leaf_data.data[contree_res.voxel_addr];
        o_res.is_hit          = true;
        o_res.pos             = contree_res.pos;
        o_res.center_pos      = contree_res.center_pos;
        o_res.is_normal_valid = (voxel_data & (1u << 29)) != 0u;
        o_res.normal          = unpack_normal_v2((voxel_data & 0x1FFFFF00u) >> 8);
        o_res.voxel_type      = voxel_data & 0xFFu;
        o_res.voxel_addr      = contree_res.voxel_addr;
        return true;
    }
    return false;
}
#include "../include/dda_scene_marching.glsl"

///

MarchingResult general_scene_marching(Ray ray) {
    return dda_scene_marching(ray.origin, ray.direction, ray.inv_direction);
}

mat3 make_tbn(vec3 normal) {
    vec3 up = abs(normal.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
    vec3 t  = normalize(cross(up, normal));
    vec3 b  = cross(normal, t);
    return mat3(t, b, normal);
}

vec3 sample_diffuse_bounce(ivec3 seed, vec3 normal) {
    vec3 weighted_cosine_bn = random_weighted_cosine_bn(seed);
    mat3 tbn                = make_tbn(normal);
    return tbn * weighted_cosine_bn;
}

vec3 sample_sun_disk(ivec3 seed, float sun_size, vec3 sun_dir) {
    vec2 random_xy = random_weighted_cosine_bn(seed).xy;
    random_xy *= sun_size;
    mat3 tbn = make_tbn(sun_dir);
    return normalize(sun_dir + tbn * vec3(random_xy.xy, 0.0));
}

/// If the ray hits the scene, no light, otherwise sunlight
vec3 get_shadow_ray_color(Ray ray, ivec3 seed) {
    if (gui_input.debug_bool == 0) {
        MarchingResult res_shadow_ray = general_scene_marching(ray);
        return res_shadow_ray.is_hit ? vec3(0.0) : sky_info.sun_color * sky_info.sun_luminance;
    } else {
        return get_shadow_weight_pcss(ray.origin, seed) * sky_info.sun_color * sky_info.sun_luminance;
    }
}

vec3 get_next_tracing_pos(vec3 voxel_center_pos, vec3 voxel_normal) {
    // gives more accurate shadow
    vec2 t                = slabs(vec3(-1.0), vec3(1.0), vec3(0.0), 1.0 / voxel_normal);
    float half_voxel_size = 1.0 / 512.0; // assuming the voxel size is 1/512
    // 0.005 is experimental to maintain a good shadow quality
    vec3 march_extent = voxel_normal * (t.y * half_voxel_size + 0.005);
    return voxel_center_pos + march_extent;
}

vec3 get_lambertian_brdf(vec3 albedo) { return albedo * INV_PI; }

void parse_trace_result(out vec3 albedo, out vec3 next_tracing_pos, MarchingResult res) {
    albedo           = voxel_color_by_type_unorm(res.voxel_type);
    next_tracing_pos = get_next_tracing_pos(res.center_pos, res.normal);
}

vec3 choose_random_normal(ivec3 seed) {
    return random_unit_vec3_bn(seed);

    vec2 rand_vec = random_unit_vec2_bn(seed);
    return vec3(rand_vec.x, 0.0,
                rand_vec.y); // This is a 2D random vector projected onto the XZ plane.
}

void get_pixel_color(out vec3 o_color, out float o_depth_01, out vec3 o_primary_normal,
                     out vec3 o_primary_position, out uint o_primary_vox_id,
                     out bool o_primary_is_hit, Ray ray, ivec3 seed) {
    MarchingResult res_primary_ray = general_scene_marching(ray);

    if (!res_primary_ray.is_hit) {
        o_depth_01         = 1.0;
        o_color            = vec3(0.0);
        o_primary_normal   = vec3(0.0);
        o_primary_position = vec3(0.0);
        o_primary_vox_id   = 0;
        o_primary_is_hit   = false;
        return;
    }

    vec4 point_ndc         = camera_info.view_proj_mat * vec4(res_primary_ray.pos, 1.0);
    float primary_depth_01 = point_ndc.z / point_ndc.w;

    o_depth_01         = primary_depth_01;
    o_primary_normal   = res_primary_ray.normal;
    o_primary_position = res_primary_ray.pos;
    o_primary_vox_id   = res_primary_ray.voxel_addr;
    o_primary_is_hit   = true;

    // if normal is not valid, change the res.normal to a random one
    if (!res_primary_ray.is_normal_valid) {
        res_primary_ray.normal = choose_random_normal(seed);
    }

    vec3 albedo, next_tracing_pos;
    parse_trace_result(albedo, next_tracing_pos, res_primary_ray);

    vec3 direct_color = vec3(0.0);

    Ray shadow_ray;
    shadow_ray.direction     = sample_sun_disk(seed, sky_info.sun_size, sky_info.sun_dir);
    shadow_ray.inv_direction = vec3(1.0) / shadow_ray.direction;
    shadow_ray.origin        = next_tracing_pos;

    float cos_i = dot(shadow_ray.direction, res_primary_ray.normal);
    if (cos_i > 0.0) {
        // we ignored the pdf and brdf calc here, because the sun's luminance is experimental
        direct_color = get_shadow_ray_color(shadow_ray, seed) * cos_i * albedo;
    }

    vec3 indirect_color = vec3(0.0);

    // MODIFICATION: Create a new, unique seed for the indirect bounce to avoid
    // reusing the same random numbers as the direct lighting, which prevents correlation.
    ivec3 indirect_seed = ivec3((seed.xy + ivec2(13, 37)) % 128, seed.z);

    Ray indirect_ray;
    indirect_ray.direction     = sample_diffuse_bounce(indirect_seed, res_primary_ray.normal);
    indirect_ray.inv_direction = vec3(1.0) / indirect_ray.direction;
    indirect_ray.origin        = next_tracing_pos;

    MarchingResult res_indirect_ray = general_scene_marching(indirect_ray);
    if (!res_indirect_ray.is_hit) {
        indirect_color = get_sky_color(indirect_ray.direction, sky_info.sky_color);
    } else {
        if (!res_indirect_ray.is_normal_valid) {
            // Use the unique indirect_seed for this random choice as well.
            res_indirect_ray.normal = choose_random_normal(indirect_seed);
        }

        vec3 sample_albedo, sample_next_tracing_pos;
        parse_trace_result(sample_albedo, sample_next_tracing_pos, res_indirect_ray);
        // only change the origin of the ray, reuse the direction for performance
        shadow_ray.origin = sample_next_tracing_pos;

        float cos_i = dot(shadow_ray.direction, res_indirect_ray.normal);
        if (cos_i > 0.0) {
            indirect_color =
                get_shadow_ray_color(shadow_ray, indirect_seed) * cos_i * sample_albedo;
        }
    }
    // see README for the brdf, pdf explanation
    indirect_color *= albedo;

    o_color = direct_color + indirect_color;
}

void main() {
    ivec2 uvi      = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(compute_output_tex);
    if (any(greaterThanEqual(uvi, img_size))) {
        return;
    }

    ivec3 seed     = get_seed(env_info.frame_serial_idx);
    vec2 screen_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(img_size);
    Ray ray        = ray_gen(screen_uv, camera_info.view_proj_mat_inv);

    vec3 color;
    float depth_01;
    vec3 primary_normal;
    vec3 primary_position;
    uint primary_vox_id;
    bool primary_is_hit;
    get_pixel_color(color, depth_01, primary_normal, primary_position, primary_vox_id,
                    primary_is_hit, ray, seed);

    vec2 uv_prev = project_world_to_screen(primary_position, camera_info_prev_frame.view_proj_mat);
    // directly using screen_uv will cause precision issue
    vec2 uv_cur     = project_world_to_screen(primary_position, camera_info.view_proj_mat);
    vec2 motion_vec = uv_prev - uv_cur;

    imageStore(compute_output_tex, uvi, uvec4(pack_rgbe(color), 0, 0, 0));
    imageStore(compute_depth_tex, uvi, vec4(depth_01, 0.0, 0.0, 1.0));

    imageStore(denoiser_normal_tex, uvi, uvec4(pack_normal_v2(primary_normal), 0, 0, 0));
    imageStore(denoiser_position_tex, uvi, vec4(primary_position, 1.0));
    imageStore(denoiser_vox_id_tex, uvi, uvec4(primary_vox_id, 0, 0, 0));
    imageStore(denoiser_motion_tex, uvi, vec4(motion_vec, 0.0, 0.0));
    imageStore(denoiser_hit_tex, uvi, uvec4(primary_is_hit ? 1 : 0, 0, 0, 1));
}
