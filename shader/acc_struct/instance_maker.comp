#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform U_InstanceInfo {
    uint instance_count;
    uvec2 blas_device_address; // 64-bit device address of your BLAS
}
instance_info;

#include "../include/grass_instance.glsl"
layout(set = 0, binding = 1) readonly buffer B_GrassInstances { GrassInstance data[]; }
grass_instances;

struct AccelStructInstance {
    mat3x4 transform;
    uint instance_custom_index_and_mask;
    uint instance_shader_binding_table_record_offset_and_flags;
    uvec2 blas_device_address;
};
layout(set = 0, binding = 2) writeonly buffer B_AccelStructInstances { AccelStructInstance data[]; }
tlas_instances;

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= instance_info.instance_count) {
        return;
    }

    GrassInstance grass_instance = grass_instances.data[id];

    vec3 rotation = vec3(0.0);
    // TODO: make the resolution configurable
    vec3 scale      = vec3(1.0 / 256.0);
    vec3 position   = vec3(grass_instance.position) / 256.0;
    uint custom_idx = 0;

    // build R from Euler XYZ
    vec3 s = sin(rotation);
    vec3 c = cos(rotation);

    mat3 r_x = mat3(1, 0, 0, 0, c.x, -s.x, 0, s.x, c.x);
    mat3 r_y = mat3(c.y, 0, s.y, 0, 1, 0, -s.y, 0, c.y);
    mat3 r_z = mat3(c.z, -s.z, 0, s.z, c.z, 0, 0, 0, 1);

    // combined rotation & scale
    mat3 M = r_z * r_y * r_x;
    M[0] *= scale.x; // scale X‐column
    M[1] *= scale.y; // scale Y‐column
    M[2] *= scale.z; // scale Z‐column

    AccelStructInstance out_inst;
    out_inst.transform =
        mat3x4(vec4(M[0], position.x), vec4(M[1], position.y), vec4(M[2], position.z));

    out_inst.instance_custom_index_and_mask = (custom_idx & 0x00FFFFFFu) // customIndex in bits 0–23
                                              | (0xFFu << 24); // mask      in bits 24–31

    uint flags = 0x1u;
    out_inst.instance_shader_binding_table_record_offset_and_flags =
        (0u & 0x00FFFFFFu) // sbt offset in bits 0–23
        | (flags << 24);   // flags      in bits 24–31

    out_inst.blas_device_address = instance_info.blas_device_address;

    tlas_instances.data[id] = out_inst;
}
