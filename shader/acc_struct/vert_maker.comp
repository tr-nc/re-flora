#version 450
#extension GL_GOOGLE_include_directive : require

// one work‐group = one 4×4×4 chunk
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#define BLAS_DIM 4
#define BLAS_DIM_2 (BLAS_DIM * BLAS_DIM)
#define NUM_CORNERS 8
#define NUM_INDICES 36

struct Vertex {
    vec3 position;
    uint padding;
    vec3 normal;
    uint normal_valid;
};
struct Index {
    uint index;
};

layout(set = 0, binding = 0) writeonly buffer B_Vertices { Vertex data[]; }
vertices;

layout(set = 0, binding = 1) writeonly buffer B_Indices { Index data[]; }
indices;

// atomic counter + readback
layout(set = 0, binding = 2) buffer B_VertMakerResult { uint valid_voxel_count; }
vert_maker_result;

// your “dummy_chunk” 4×4×4 voxel types
uint dummy_chunk[] = uint[](
    // z=0
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // z=1
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // z=2
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // z=3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

// safe fetch (0 outside)
uint get_voxel_type(ivec3 c) {
    if (any(lessThan(c, ivec3(0))) || any(greaterThanEqual(c, ivec3(BLAS_DIM)))) {
        return 0;
    }
    return dummy_chunk[c.x + c.y * BLAS_DIM_2 + c.z * BLAS_DIM];
}

// fully‐occluded iff all 6 neighbors are solid
bool is_occluded(ivec3 c) {
    ivec3 offs[6] = ivec3[](ivec3(1, 0, 0), ivec3(-1, 0, 0), ivec3(0, 1, 0), ivec3(0, -1, 0),
                            ivec3(0, 0, 1), ivec3(0, 0, -1));
    for (int i = 0; i < 6; i++) {
        if (get_voxel_type(c + offs[i]) == 0) {
            return false;
        }
    }
    return true;
}

// from https://www.youtube.com/watch?v=YTZBFz3Et40
void calculate_normal(out vec3 o_normal, out bool o_is_valid, ivec3 c) {
    const int R = 2;
    vec3 n      = vec3(0.0);
    for (int z = -R; z <= R; z++) {
        for (int y = -R; y <= R; y++) {
            for (int x = -R; x <= R; x++) {
                if (get_voxel_type(c + ivec3(x, y, z)) != 0) {
                    n += vec3(x, y, z);
                }
            }
        }
    }
    float L    = length(n);
    o_is_valid = (L > 1e-5);
    o_normal   = o_is_valid ? normalize(-n) : vec3(0, 1, 0);
}

// 1×1×1 cube centered at (0,0,0)
const vec3 cube_corners[NUM_CORNERS] = vec3[](
    vec3(-0.5, -0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(0.5, 0.5, -0.5), vec3(-0.5, 0.5, -0.5),
    vec3(-0.5, -0.5, 0.5), vec3(0.5, -0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(-0.5, 0.5, 0.5));
// two‐triangles‐per‐face
const uint cube_indices[NUM_INDICES] = uint[](0, 1, 2, 2, 3, 0, 4, 6, 5, 6, 4, 7, 0, 3, 7, 7, 4, 0,
                                              1, 5, 6, 6, 2, 1, 0, 4, 5, 5, 1, 0, 3, 2, 6, 6, 7, 3);

void main() {
    ivec3 uvi = ivec3(gl_GlobalInvocationID);
    if (any(lessThan(uvi, ivec3(0))) || any(greaterThanEqual(uvi, ivec3(BLAS_DIM)))) {
        return;
    }

    uint vt = get_voxel_type(uvi);

    // empty
    if (vt == 0) {
        return;
    }

    // fully hidden
    if (is_occluded(uvi)) {
        return;
    }

    // compute per‐voxel normal
    vec3 normal;
    bool valid;
    calculate_normal(normal, valid, uvi);

    // reserve one “voxel slot”
    uint slot = atomicAdd(vert_maker_result.valid_voxel_count, 1);

    // write 8 verts + bake the *same* normal into all of them
    for (uint i = 0; i < NUM_CORNERS; i++) {
        uint out_idx                        = slot * NUM_CORNERS + i;
        vertices.data[out_idx].position     = vec3(uvi) + cube_corners[i];
        vertices.data[out_idx].normal       = normal;
        vertices.data[out_idx].normal_valid = valid ? 1 : 0;
        // TODO: store normal validity too
    }

    // write 36 indices (offset into this slot’s 8 verts)
    for (uint i = 0; i < NUM_INDICES; i++) {
        uint out_idx                = slot * NUM_INDICES + i;
        indices.data[out_idx].index = slot * NUM_CORNERS + cube_indices[i];
    }
}
