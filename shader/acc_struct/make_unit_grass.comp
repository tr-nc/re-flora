#version 450

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#include "../include/vertex_index_attribute.glsl"

layout(set = 0, binding = 0) uniform U_MakeUnitGrassInfo { vec2 bend_dir_and_strength; }
make_unit_grass_info;

const uint grass_blade_voxel_length = 8u;

layout(set = 0, binding = 1) writeonly buffer B_Vertices { Vertex data[]; }
vertices;
layout(set = 0, binding = 2) writeonly buffer B_Indices { Index data[]; }
indices;
layout(set = 0, binding = 3) writeonly buffer B_BlasBuildResult {
    uint vertices_len;
    uint indices_len;
}
blas_build_result;

// Appends one axis-aligned cube into the global vertex/index buffers.
void append_cube(inout uint io_vertex_offset, inout uint io_index_offset, vec3 center) {
    const vec3 base_verts[8] = vec3[](
        vec3(-0.5, -0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(0.5, 0.5, -0.5), vec3(-0.5, 0.5, -0.5),
        vec3(-0.5, -0.5, 0.5), vec3(0.5, -0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(-0.5, 0.5, 0.5));
    const uint base_indices[36] = uint[](0, 1, 2, 2, 3, 0, // -Z
                                         4, 6, 5, 6, 4, 7, // +Z
                                         0, 3, 7, 7, 4, 0, // -X
                                         1, 5, 6, 6, 2, 1, // +X
                                         0, 4, 5, 5, 1, 0, // -Y
                                         3, 2, 6, 6, 7, 3  // +Y
    );

    // Write vertices
    for (uint i = 0u; i < 8u; ++i) {
        vertices.data[io_vertex_offset + i].position = base_verts[i] + center;
    }
    // Write indices (with bias)
    for (uint i = 0u; i < 36u; ++i) {
        // Assuming 'Index' is a struct { uint index; }, common in packed GLSL
        indices.data[io_index_offset + i].index = io_vertex_offset + base_indices[i];
    }
    io_vertex_offset += 8u;
    io_index_offset += 36u;
}

// Builds one grass blade as a vertical stack of 'voxel_count' cubes.
// The final position of each cube is rounded to enforce the grid-snapped aesthetic.
void draw_grass_blade(inout uint io_vertex_offset, inout uint io_index_offset,
                      vec2 bend_dir_and_strength, vec3 offset, uint voxel_count) {
    if (voxel_count == 0u) {
        return;
    }

    // Avoid division by zero if the blade has only one voxel.
    float denom = float(max(voxel_count - 1u, 1u));

    for (uint i = 0u; i < voxel_count; ++i) {
        float t       = float(i) / denom;
        float t_curve = t * t; // ease-in curve for a natural bend

        // Calculate the floating-point position of the cube's center.
        vec3 float_center = vec3(bend_dir_and_strength.x * t_curve, // X bend
                                 float(i),                          // Y position
                                 bend_dir_and_strength.y * t_curve  // Z bend
        );

        // Round the position to the nearest integer grid point. This ensures
        // all cubes are perfectly axis-aligned and grid-snapped.
        vec3 snapped_center = round(float_center) + 0.5 + vec3(0.0, 1.0, 0.0);

        append_cube(io_vertex_offset, io_index_offset, snapped_center + offset);
    }
}

void main() {
    // Initialize offsets to zero.
    uint vertex_offset = 0;
    uint index_offset  = 0;

    // Generate a single blade of grass at the origin (0,0,0) using the
    // parameters provided by the uniform buffer.
    draw_grass_blade(vertex_offset, index_offset, make_unit_grass_info.bend_dir_and_strength,
                     vec3(0.0), // Generate at the local origin, no offset.
                     grass_blade_voxel_length);

    // Write the final counts of the generated geometry so the CPU knows
    // the size of the data to use for the BLAS build.
    blas_build_result.vertices_len = vertex_offset;
    blas_build_result.indices_len  = index_offset;
}
