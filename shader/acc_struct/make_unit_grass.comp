#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#include "../include/vertex_index_attribute.glsl"

layout(set = 0, binding = 0) uniform U_MakeUnitGrassInfo { vec2 bend_dir_and_strength; }
make_unit_grass_info;
layout(set = 0, binding = 1) writeonly buffer B_Vertices { Vertex data[]; }
vertices;
layout(set = 0, binding = 2) writeonly buffer B_Indices { Index data[]; }
indices;
layout(set = 0, binding = 3) writeonly buffer B_BlasBuildResult {
    uint vertices_len;
    uint indices_len;
}
blas_build_result;

// Appends one cube into the global vertex/index buffers.
void append_cube(inout uint io_vertex_offset, inout uint io_index_offset, vec3 center, vec3 scale) {
    const vec3 base_verts[8] = vec3[](
        vec3(-0.5, -0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(0.5, 0.5, -0.5), vec3(-0.5, 0.5, -0.5),
        vec3(-0.5, -0.5, 0.5), vec3(0.5, -0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(-0.5, 0.5, 0.5));
    const uint base_indices[36] = uint[](0, 1, 2, 2, 3, 0, // -Z
                                         4, 6, 5, 6, 4, 7, // +Z
                                         0, 3, 7, 7, 4, 0, // -X
                                         1, 5, 6, 6, 2, 1, // +X
                                         0, 4, 5, 5, 1, 0, // -Y
                                         3, 2, 6, 6, 7, 3  // +Y
    );

    // write verts
    for (uint i = 0u; i < 8u; ++i) {
        vec3 pos                                     = base_verts[i] * scale + center;
        vertices.data[io_vertex_offset + i].position = pos;
    }
    // write indices (with bias)
    for (uint i = 0u; i < 36u; ++i) {
        indices.data[io_index_offset + i].index = io_vertex_offset + base_indices[i];
    }
    io_vertex_offset += 8u;
    io_index_offset += 36u;
}

// Builds one grass blade as a vertical stack of 'voxel_count' cubes.
// -- The bottom cube sits at Y=0.
// -- The top cube sits at Y=voxel_count-1, and is bent full‐strength in X and Z.
// -- Intermediate cubes have Y = their integer index, but X/Z are bent by t² ease‐in.
void draw_grass_blade(inout uint io_vertex_offset, inout uint io_index_offset,
                      vec2 bend_dir_and_strength, vec3 offset, uint voxel_count) {
    if (voxel_count == 0u) {
        return;
    }

    // number of intervals = voxel_count-1 (clamp to 1 to avoid div0)
    float denom = float(max(voxel_count - 1u, 1u));

    for (uint i = 0u; i < voxel_count; ++i) {
        float t       = float(i) / denom;
        float t_curve = t * t; // ease‐in: gentle near base, stronger near tip

        // Y is uniform step = i
        float y = float(i);

        // X/Z are bent along the ease‐in from 0→bend
        float x = bend_dir_and_strength.x * t_curve;
        float z = bend_dir_and_strength.y * t_curve;

        vec3 center = vec3(x, y, z) + offset;
        append_cube(io_vertex_offset, io_index_offset, center, vec3(1.0));
    }
}

const uint GRASS_CHUNK_DIM  = 8;
const uint GRASS_CHUNK_SIZE = GRASS_CHUNK_DIM * GRASS_CHUNK_DIM;

vec3[GRASS_CHUNK_SIZE] make_grass_offsets(vec3 base_offset) {
    vec3 offsets[GRASS_CHUNK_SIZE];
    for (uint i = 0; i < GRASS_CHUNK_SIZE; ++i) {
        float x    = float(i % GRASS_CHUNK_DIM);
        float z    = float(i / GRASS_CHUNK_DIM);
        offsets[i] = base_offset + vec3(x, 0.0, z);
    }
    return offsets;
}

// Added a simple pseudo-random number generator (hash function)
// It produces a deterministic random-looking value between 0.0 and 1.0 based on input coordinates.
float rand(vec2 co) { return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453); }

// Add a configurable chance for a grass blade to be absent.
// A value of 0.2 means a 20% chance of no grass. Set to 0.0 for 100% density.
const float CHANCE_OF_NO_GRASS = 0.8;

// Modified this function to generate random heights and to potentially skip blades.
uint[GRASS_CHUNK_SIZE] make_grass_lengths(vec3 offsets[GRASS_CHUNK_SIZE]) {
    uint lengths[GRASS_CHUNK_SIZE];
    uint min_height   = 3u;
    uint max_height   = 8u;
    uint height_range = max_height - min_height;

    for (uint i = 0; i < GRASS_CHUNK_SIZE; ++i) {
        // Use the position to generate a random value for the existence check.
        float existence_rand = rand(offsets[i].xz);

        if (existence_rand < CHANCE_OF_NO_GRASS) {
            // If the random value falls within the chance, set length to 0.
            // The draw_grass_blade function will skip drawing blades with 0 length.
            lengths[i] = 0u;
        } else {
            // If the grass exists, calculate its height.
            // Use a different seed for the height randomness to decouple it from existence.
            // Swizzling the input vector (.zx) is a simple way to get a different random sequence.
            float height_rand = rand(offsets[i].zx);

            // Map the random value to our desired height range
            lengths[i] = min_height + uint(height_rand * float(height_range));
        }
    }
    return lengths;
}

void main() {
    uint vertex_offset = 0;
    uint index_offset  = 0;

    vec3 base_grass_offset = vec3(0.5, 0.0, 0.5);
    vec3 grass_offsets[]   = make_grass_offsets(base_grass_offset);
    uint grass_lengths[]   = make_grass_lengths(grass_offsets);

    for (uint i = 0; i < GRASS_CHUNK_SIZE; ++i) {
        vec3 offset       = grass_offsets[i];
        uint grass_length = grass_lengths[i];
        draw_grass_blade(vertex_offset, index_offset, make_unit_grass_info.bend_dir_and_strength,
                         offset, grass_length);
    }

    blas_build_result.vertices_len = vertex_offset;
    blas_build_result.indices_len  = index_offset;
}
