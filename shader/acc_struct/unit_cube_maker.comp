#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#include "../include/vertex_index_attribute.glsl"

// Must be sized large enough to hold all generated vertices (43 planes × 4 vertices each = 172)
layout(set = 0, binding = 0) writeonly buffer B_Vertices { Vertex data[]; }
vertices;
// Must be sized large enough to hold all generated indices (43 planes × 6 indices each = 258)
layout(set = 0, binding = 1) writeonly buffer B_Indices { Index data[]; }
indices;

void main() {
    const int GX = 16; // grid size in +X
    const int GY = 8;  // grid size in +Y
    const int GZ = 16; // grid size in +Z

    uint currentVertex = 0u;
    uint currentIndex  = 0u;

// Helper lambda to emit one quad (two triangles) given 4 corner positions
// Assumes CCW winding when viewed from outside the volume.
#define EMIT_QUAD(p0, p1, p2, p3)                                                                  \
    /* write 4 vertices */                                                                         \
    vertices.data[currentVertex + 0u].position = p0;                                               \
    vertices.data[currentVertex + 1u].position = p1;                                               \
    vertices.data[currentVertex + 2u].position = p2;                                               \
    vertices.data[currentVertex + 3u].position = p3;                                               \
                                                                                                   \
    /* write 6 indices */                                                                          \
    indices.data[currentIndex + 0u].index = currentVertex + 0u;                                    \
    indices.data[currentIndex + 1u].index = currentVertex + 1u;                                    \
    indices.data[currentIndex + 2u].index = currentVertex + 2u;                                    \
    indices.data[currentIndex + 3u].index = currentVertex + 2u;                                    \
    indices.data[currentIndex + 4u].index = currentVertex + 3u;                                    \
    indices.data[currentIndex + 5u].index = currentVertex + 0u;                                    \
                                                                                                   \
    currentVertex += 4u;                                                                           \
    currentIndex += 6u;

    // 1) Horizontal planes (parallel to XZ), at y = 0..GY (GY+1 planes)
    for (int y = 0; y <= GY; ++y) {
        vec3 p0 = vec3(0.0, float(y), 0.0);
        vec3 p1 = vec3(float(GX), float(y), 0.0);
        vec3 p2 = vec3(float(GX), float(y), float(GZ));
        vec3 p3 = vec3(0.0, float(y), float(GZ));
        EMIT_QUAD(p0, p1, p2, p3)
    }

    // 2) Vertical planes (parallel to YZ), at x = 0..GX (GX+1 planes)
    for (int x = 0; x <= GX; ++x) {
        vec3 p0 = vec3(float(x), 0.0, 0.0);
        vec3 p1 = vec3(float(x), float(GY), 0.0);
        vec3 p2 = vec3(float(x), float(GY), float(GZ));
        vec3 p3 = vec3(float(x), 0.0, float(GZ));
        EMIT_QUAD(p0, p1, p2, p3)
    }

    // 3) Vertical planes (parallel to XY), at z = 0..GZ (GZ+1 planes)
    for (int z = 0; z <= GZ; ++z) {
        vec3 p0 = vec3(0.0, 0.0, float(z));
        vec3 p1 = vec3(float(GX), 0.0, float(z));
        vec3 p2 = vec3(float(GX), float(GY), float(z));
        vec3 p3 = vec3(0.0, float(GY), float(z));
        EMIT_QUAD(p0, p1, p2, p3)
    }

#undef EMIT_QUAD
}
