#version 450

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly uniform B_OctreeBuildInfo {
    uint fragment_list_len;
    uint voxel_dim_xyz;
}
octree_build_info;
layout(set = 0, binding = 1) writeonly buffer B_OctreeAllocInfo {
    uint alloc_begin;
    uint alloc_num;
}
octree_alloc_info;

layout(set = 1, binding = 0) buffer B_OctreeData { uint data[]; }
octree_data;
#include "../../include/fragment_list_entry.glsl"
layout(set = 1, binding = 1) readonly buffer B_FragmentList {
    FragmentListEntry per_voxel_build_infos[];
}
fragment_list;

#include "../../include/config.glsl"

uvec4 leaf_to_uvec4(uint val) {
    return uvec4((val & 0xFF), ((val >> 8) & 0xFF), ((val >> 16) & 0xFF), ((val >> 24) & 0x3F));
}
uint uvec4_to_leaf(uvec4 vec) {
    return (min(vec.w, 0x3F) << 24) | (vec.x & 0xFF) | ((vec.y & 0xFF) << 8) |
           ((vec.z & 0xFF) << 16) | 0xC0000000;
}

// returns the index of the node to be tagged (it has just been initialized to
// 0)
uint traverse_octree(out bool is_leaf, uvec3 voxel_pos, uint level_dim) {
    uvec3 level_pos = voxel_pos;

    uint idx = 0u, cur = 0u;
    do {
        // fast division by 2, level_dim must be 2^n, where n >= 0
        bvec3 cmp = greaterThanEqual(level_pos, uvec3(level_dim >>= 1));
        idx       = cur | uint(cmp.x) | (uint(cmp.y) << 1) | (uint(cmp.z) << 2);
        cur       = octree_data.data[idx] & 0x3FFFFFFF; // read node pointer
        level_pos -= uvec3(cmp) * level_dim;
    } while (cur != 0 && level_dim > 1u);
    is_leaf = level_dim == 1u;
    return idx;
}

void main() {
    if (gl_GlobalInvocationID.x >= octree_build_info.fragment_list_len) {
        return;
    }
    FragmentListEntry ufragment = fragment_list.per_voxel_build_infos[gl_GlobalInvocationID.x];

    uint coordinates = ufragment.coordinates;
    uvec3 voxel_pos  = uvec3((coordinates & 0x000003FF), (coordinates & 0x000FFC00) >> 10,
                             (coordinates & 0x3FF00000) >> 20);

    bool is_leaf;
    // is_leaf is only true when the leaf node is allocated
    uint idx = traverse_octree(is_leaf, voxel_pos, octree_build_info.voxel_dim_xyz);

    if (is_leaf) {
        uint properties       = ufragment.properties;
        octree_data.data[idx] = 0xC0000000u | properties;
    } else
        // flag the node so it can be subdivided (using msb)
        octree_data.data[idx] = 0x80000000u;
}
