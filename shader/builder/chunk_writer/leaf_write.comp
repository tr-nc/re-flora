#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 0, binding = 0) readonly uniform U_LeafWriteInfo {
    vec3 leaf_color; // TODO: remove this
    uvec3 atlas_write_offset;
    uvec3 atlas_write_dim;
}
leaf_write_info;

layout(set = 0, binding = 1, r8ui) writeonly uniform uimage3D atlas;

#include "../../include/core/hash.glsl"
#include "../../include/voxel_type.glsl"

float random_float_01(vec3 p) {
    // if all three are integer values, the noise is fixed to zero
    return construct_float_01(murmur_hash_13(floatBitsToUint(p)));
}

/// density ranges from 0 to 1
uint get_voxel_type(float density, ivec3 uvi, float radius_cutoff, float solid_leaf_radius) {
    float current_r = length(vec3(uvi) - vec3(leaf_write_info.atlas_write_dim) * 0.5);
    current_r /= length(vec3(leaf_write_info.atlas_write_dim) * 0.5); // normalize to [0, 1]

    if (current_r > radius_cutoff) {
        return VOXEL_TYPE_EMPTY;
    }

    if (current_r < solid_leaf_radius) {
        return VOXEL_TYPE_EMPTY;
    }

    const float noise = random_float_01(vec3(uvi));
    if (noise < density) {
        return VOXEL_TYPE_LEAF;
    }
    return VOXEL_TYPE_EMPTY;
}

void main() {
    ivec3 uvi = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(uvi, ivec3(leaf_write_info.atlas_write_dim)))) {
        return;
    }

    const float density           = 0.02;
    const float radius_cutoff     = 0.56;
    const float solid_leaf_radius = 0.45;

    uint voxel_type = get_voxel_type(density, uvi, radius_cutoff, solid_leaf_radius);

    ivec3 atlas_base_offset = ivec3(leaf_write_info.atlas_write_offset);
    imageStore(atlas, atlas_base_offset + uvi, uvec4(voxel_type, 0, 0, 0));
}
