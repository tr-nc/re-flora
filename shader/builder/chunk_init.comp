#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 0, binding = 0) readonly uniform U_ChunkBuildInfo {
    uvec3 chunk_res;
    ivec3 chunk_pos;
}
chunk_build_info;

// Instead of writing to an image, we write to a buffer.
layout(set = 1, binding = 0) writeonly buffer B_RawBlocks { uint data[]; }
raw_blocks;

#include "../include/core/inoise.glsl"
#include "../include/voxel_types.glsl"

float compute_noise(vec3 p) {
    float total       = 0.0;
    float amplitude   = 0.5;
    float frequency   = 2.0;
    float persistence = 0.3;
    float lacunarity  = 2.2;
    int octaves       = 5;

    for (int i = 0; i < octaves; i++) {
        vec4 noise = noised(p * frequency);
        total += amplitude * (noise.x + 0.5);
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    return total;
}

uint get_voxel_type(float weight) {
    if (weight < 0.0) {
        return VOXEL_TYPE_EMPTY;
    }
    return VOXEL_TYPE_DIRT;
}

void main() {
    // Compute the voxel coordinate.
    // The dispatch dimensions should match the total voxel count.
    ivec3 uvi = ivec3(gl_GlobalInvocationID);

    // Discard out-of-bound invocations.
    if (any(greaterThanEqual(uvi, ivec3(chunk_build_info.chunk_res)))) {
        return;
    }

    // Compute local and world positions.
    vec3 local_voxel_pos = (vec3(uvi) - 0.5) / vec3(chunk_build_info.chunk_res);
    vec3 world_voxel_pos = local_voxel_pos + vec3(chunk_build_info.chunk_pos);

    float noise     = compute_noise(world_voxel_pos);
    float weight    = noise - world_voxel_pos.y;
    uint voxel_type = get_voxel_type(weight);

    // Compute the linear voxel index assuming row-major ordering:
    // linear_index = uvi.z * (chunk_res.x * chunk_res.y) + uvi.y * chunk_res.x + uvi.x
    uint linear_index =
        uint(uvi.z) * (chunk_build_info.chunk_res.x * chunk_build_info.chunk_res.y) +
        uint(uvi.y) * chunk_build_info.chunk_res.x + uint(uvi.x);

    // Determine destination uint index and the byte offset (0, 1, 2, or 3).
    uint dest_index   = linear_index / 4;
    uint byte_offset  = linear_index % 4;
    uint shift_amount = byte_offset * 8u;

    // Shift the voxel value (8-bit) to its position and atomically OR into the destination uint.
    uint shifted_val = voxel_type << shift_amount;
    atomicOr(raw_blocks.data[dest_index], shifted_val);
}
