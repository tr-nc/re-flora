#version 450

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(set = 0, binding = 0) readonly uniform U_ContreeBuildInfo {
    uint dim; // the dimension of the contree to be built, uniform in x, y, z
    uint max_level;
    uint node_write_offset; // the offset in the global node buffer
    uint leaf_write_offset; // the offset in the global leaf buffer
}
contree_build_info;

layout(set = 0, binding = 1) readonly buffer B_ContreeBuildState {
    uint prev_dim;
    uint curr_dim;
    uint level;
}
contree_build_state;

layout(set = 0, binding = 2, r32ui) readonly uniform uimage3D surface;

layout(set = 0, binding = 3) readonly buffer B_NodeOffsetForLevels { uint data[]; }
node_offset_for_levels;

#include "../../include/contree_node.glsl"
layout(set = 0, binding = 4) writeonly buffer B_SparseNodes { ContreeNode data[]; }
sparse_nodes;

layout(set = 0, binding = 5) writeonly buffer B_ContreeLeafData { uint data[]; }
contree_leaf_data;

layout(set = 0, binding = 6) writeonly buffer B_ContreeBuildResult {
    uint node_len;
    uint leaf_len;
}
contree_build_result;

#include "../../include/core/bits.glsl"

shared uint shared_invocation_data[64];
shared uint group_base;

void cleanup_shared_invocation_data(uint local_invocation_idx) {
    shared_invocation_data[local_invocation_idx] = 0;
    barrier();
}

uint register_and_get_local_base(uint invocation_cnt, uint local_invocation_idx) {
    shared_invocation_data[local_invocation_idx] = invocation_cnt;
    barrier();

    if (local_invocation_idx == 0) {
        uint current_prefix_sum = 0;
        for (uint i = 0; i < 64; ++i) {
            uint count_at_i           = shared_invocation_data[i];
            shared_invocation_data[i] = current_prefix_sum;
            current_prefix_sum += count_at_i;
        }
        uint total_workgroup_cnt = current_prefix_sum;
        group_base               = atomicAdd(contree_build_result.leaf_len, total_workgroup_cnt);
    }

    barrier();
    uint local_offset_within_group = shared_invocation_data[local_invocation_idx];
    return group_base + local_offset_within_group;
}

void main() {
    cleanup_shared_invocation_data(gl_LocalInvocationIndex);
    ivec3 uvi = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(uvi, ivec3(contree_build_state.curr_dim)))) {
        return;
    }

    uint temp[64];
    uint64_t child_mask = 0;
    for (uint yi = 0; yi < 4; yi++) {
        for (uint zi = 0; zi < 4; zi++) {
            for (uint xi = 0; xi < 4; xi++) {
                uint i = xi + zi * 4 + yi * 16;

                ivec3 vpos = uvi * 4 + ivec3(xi, yi, zi);
                uint v     = imageLoad(surface, vpos).x;
                temp[i]    = v;

                // the node is valid if voxel type is non zero
                bool exists = (v != 0);
                child_mask |= exists ? (uint64_t(1) << i) : 0ul;
            }
        }
    }

    uint cnt  = bit_count_u64(child_mask);
    uint base = register_and_get_local_base(cnt, gl_LocalInvocationIndex);

    uint sparse_node_write_offset = node_offset_for_levels.data[contree_build_state.level];
    uint brick_idx                = uint(uvi.x) + uint(uvi.z) * contree_build_state.curr_dim +
                     uint(uvi.y) * contree_build_state.curr_dim * contree_build_state.curr_dim;
    brick_idx += sparse_node_write_offset;

    // early out: if no voxels are presented in this brick
    if (cnt == 0) {
        sparse_nodes.data[brick_idx].packed_0   = 0;
        sparse_nodes.data[brick_idx].child_mask = 0ul;
        return;
    }

    // If there are valid voxels, write their data to the contree_leaf_data buffer.
    // 'w' tracks the number of voxels written by this invocation.
    uint w = 0;
    for (uint i = 0; i < 64; i++) {
        // Check if the i-th voxel in the 4x4x4 brick is valid.
        if ((child_mask & (uint64_t(1) << i)) != 0) {
            contree_leaf_data.data[contree_build_info.leaf_write_offset + base + w] = temp[i];
            w++;
        }
    }

    // because we are using 31 bits for the leaf ptr, there's a limit of 1290^3 of total voxels pre
    // chunk
    // 1290^3 = 2146689000, 2^31 = 2147483648, so we are safe
    // so the maximum available voxel dim limit is 1024^3, to match the 4^n dimension need of
    // contree
    sparse_nodes.data[brick_idx].packed_0   = 1 | (base << 1);
    sparse_nodes.data[brick_idx].child_mask = child_mask;
}
