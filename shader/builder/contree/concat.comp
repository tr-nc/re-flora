//! The last pass that is used to make the actual contree structure
#version 450

#extension GL_GOOGLE_include_directive : require

layout(set = 0, binding = 0) readonly buffer B_NodeOffsetForLevels { uint data[]; }
node_offset_for_levels;

#include "../../include/contree_node.glsl"
layout(set = 0, binding = 1) readonly buffer B_DenseNodes { ContreeNode data[]; }
dense_nodes;

layout(set = 0, binding = 2) readonly buffer B_CounterForLevels { uint data[]; }
counter_for_levels;

layout(set = 0, binding = 3) writeonly buffer B_ContreeData { ContreeNode data[]; }
contree_data;

layout(set = 0, binding = 4) readonly buffer B_ContreeBuildResult { uint len; }
contree_build_result;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#include "../../include/core/bits.glsl"

void main() {
    uint idx = gl_GlobalInvocationID.x;

    // this buffer is filled inside each tree_write
    if (idx >= contree_build_result.len) {
        return;
    }

    const uint counter_len = 10;

    uint prefix_sums[counter_len];
    prefix_sums[0] = counter_for_levels.data[0]; // it should be 1
    for (uint i = 1; i < counter_len; i++) {
        prefix_sums[i] = prefix_sums[i - 1] + counter_for_levels.data[i];
    }
    uint total_len = prefix_sums[counter_len - 1]; // just an alias

    for (uint i = 0; i < counter_len; i++) {
        if (idx < prefix_sums[i]) {
            uint offset    = node_offset_for_levels.data[i];
            uint local_idx = idx - (i == 0 ? 0 : prefix_sums[i - 1]);

            ContreeNode fetched  = dense_nodes.data[offset + local_idx];
            uint relative_offset = fetched.packed_0 >> 1;
            uint abs_offset      = relative_offset + prefix_sums[i];

            ContreeNode cn;
            cn.packed_0   = (fetched.packed_0 & 1u) | (abs_offset << 1);
            cn.child_mask = fetched.child_mask;

            contree_data.data[idx] = cn;
            break;
        }
    }
}
