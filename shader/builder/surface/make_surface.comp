#version 450

#extension GL_GOOGLE_include_directive : require

#define GROUP_SIZE 8
#define GROUP_SIZE_3 (GROUP_SIZE * GROUP_SIZE * GROUP_SIZE)
layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = GROUP_SIZE) in;

layout(set = 0, binding = 0) readonly uniform U_MakeSurfaceInfo {
    uvec3 atlas_read_offset;
    uvec3 atlas_read_dim;
    uint is_crossing_boundary; // bool
}
make_surface_info;

layout(set = 0, binding = 1) buffer B_MakeSurfaceResult {
    uint active_voxel_len;
    uint grass_instance_len;
}
make_surface_result;

layout(set = 0, binding = 2, r32ui) writeonly uniform uimage3D surface;

layout(set = 0, binding = 3, r8ui) readonly uniform uimage3D atlas;

#include "../../include/grass_instance.glsl"
layout(set = 0, binding = 4) writeonly buffer B_GrassInstances { GrassInstance data[]; }
grass_instances;

#include "../../include/config.glsl"
#include "../../include/core/definitions.glsl"
#include "../../include/core/fast_noise_lite.glsl"
#include "../../include/core/packer.glsl"
#include "../../include/grass_type.glsl"
#include "../../include/voxel_registry.glsl"

#define SHARED_SIZE (GROUP_SIZE + 4) // 4 for halo
#define SHARED_SIZE_3 (SHARED_SIZE * SHARED_SIZE * SHARED_SIZE)
shared uint shared_data[SHARED_SIZE][SHARED_SIZE][SHARED_SIZE];

ivec3 shared_idx_to_atlas_idx(ivec3 chunk_base, ivec3 shared_idx) {
    const ivec3 group_base = ivec3(gl_WorkGroupID) * GROUP_SIZE - 2; // include halo
    ivec3 atlas_idx        = shared_idx + group_base + chunk_base;
    return atlas_idx;
}

ivec3 local_idx_to_shared_idx(ivec3 local_idx) {
    const ivec3 group_base = ivec3(gl_WorkGroupID) * GROUP_SIZE - 2; // include halo
    return local_idx - group_base;
}

uint load_atlas(ivec3 atlas_idx, ivec3 atlas_read_offset, ivec3 atlas_read_dim,
                bool is_crossing_boundary) {
    if (is_crossing_boundary) {
        return imageLoad(atlas, atlas_idx).r;
    } else {
        if (any(lessThan(atlas_idx, atlas_read_offset)) ||
            any(greaterThanEqual(atlas_idx, atlas_read_offset + atlas_read_dim))) {
            return 0;
        }
        return imageLoad(atlas, atlas_idx).r;
    }
}

void preload() {
    // load operations from any texel that is outside of the boundaries of the bound image will
    // return all zeros
    for (uint linear_idx = gl_LocalInvocationIndex; linear_idx < SHARED_SIZE_3;
         linear_idx += GROUP_SIZE_3) {

        uvec3 shared_idx;
        shared_idx.x = linear_idx % SHARED_SIZE;
        shared_idx.y = (linear_idx / SHARED_SIZE) % SHARED_SIZE;
        shared_idx.z = linear_idx / (SHARED_SIZE * SHARED_SIZE);

        ivec3 atlas_idx =
            shared_idx_to_atlas_idx(ivec3(make_surface_info.atlas_read_offset), ivec3(shared_idx));
        uint val = load_atlas(atlas_idx, ivec3(make_surface_info.atlas_read_offset),
                              ivec3(make_surface_info.atlas_read_dim),
                              make_surface_info.is_crossing_boundary != 0);

        shared_data[shared_idx.x][shared_idx.y][shared_idx.z] = val;
    }
}

bool is_solid(uint voxel_type) { return voxel_type != VOXEL_TYPE_EMPTY; }

uint voxel_at_local_idx(ivec3 local_idx) {
    ivec3 shared_idx = local_idx_to_shared_idx(local_idx);
    return shared_data[shared_idx.x][shared_idx.y][shared_idx.z];
}

/// Check if a block is occluded by its neighbours.
/// A block is occluded if all of its neighbours are solid.
bool is_occluded(ivec3 uvi) {
    ivec3 neighbours_to_check[6] = {
        ivec3(1, 0, 0),  ivec3(-1, 0, 0), ivec3(0, 1, 0),
        ivec3(0, -1, 0), ivec3(0, 0, 1),  ivec3(0, 0, -1),
    };

    for (int i = 0; i < 6; i++) {
        ivec3 cur = uvi + neighbours_to_check[i];

        uint voxel_type = voxel_at_local_idx(cur);

        if (!is_solid(voxel_type)) {
            return false;
        }
    }
    return true;
}

void calculate_normal(out vec3 o_normal, out bool o_is_normal_valid, ivec3 uvi) {
    const ivec3 min_bound = ivec3(-2);
    const ivec3 max_bound = ivec3(2);

    vec3 normal = vec3(0.0);
    for (int z = min_bound.z; z <= max_bound.z; z++) {
        for (int y = min_bound.y; y <= max_bound.y; y++) {
            for (int x = min_bound.x; x <= max_bound.x; x++) {
                ivec3 offset = ivec3(x, y, z);

                // center voxel is not skipped for performance reasons

                ivec3 cur       = uvi + offset;
                uint voxel_type = voxel_at_local_idx(cur);

                // no weighting is applied for the normal calculation

                if (is_solid(voxel_type)) {
                    normal += vec3(offset);
                }
            }
        }
    }
    o_is_normal_valid = length(normal) > EPSILON;
    if (o_is_normal_valid) {
        o_normal = normalize(-normal);
    }
}

/// Threhold ranges from 0.0 to 1.0.
bool normal_not_too_steep(vec3 normal, float threhold) {
    vec3 up = vec3(0.0, 1.0, 0.0);
    return dot(normal, up) > threhold;
}

/// Compress a coordinate into a single uint.
/// The coordinate is compressed into 3 10-bit components.
/// Total occupied bits: 10 * 3 = 30 bits.
uint compress_coord(ivec3 coord) {
    uint coord_compressed = coord.x;
    coord_compressed |= coord.y << 10;
    coord_compressed |= coord.z << 20;
    return coord_compressed;
}

/// Compress a voxel type and normal vector into a single uint.
/// The voxel type is compressed into 8 bits, the normal vector is compressed into 3 7-bit
/// components, and the is_normal_valid flag is compressed into 1 bit.
/// Total occupied bits: 8 + 21 + 1 = 30 bits.
uint compress_voxel_type_and_normal(uint voxel_type, vec3 normal, bool is_normal_valid) {
    uint properties_data = 0;
    properties_data |= voxel_type & 0xFF;
    properties_data |= pack_normal_v2(normal) << 8; // 7 bits for each component -> total 21 bits
    properties_data |= (is_normal_valid ? 1 : 0) << 29; // 1 bit for is_normal_valid
    return properties_data;
}

bool is_surface_top(ivec3 p) { return !is_solid(voxel_at_local_idx(p + ivec3(0, 1, 0))); }

bool is_surface_plantable(uint voxel_type) { return voxel_type != VOXEL_TYPE_TRUNK; }

void main() {
    preload();
    barrier();

    ivec3 uvi = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(uvi, ivec3(make_surface_info.atlas_read_dim)))) {
        return;
    }

    uint voxel_type = voxel_at_local_idx(uvi);
    if (!is_solid(voxel_type)) {
        return;
    }

    if (is_occluded(uvi)) {
        return;
    }

    vec3 normal;
    bool is_normal_valid;
    calculate_normal(normal, is_normal_valid, uvi);
    uint properties = compress_voxel_type_and_normal(voxel_type, normal, is_normal_valid);

    atomicAdd(make_surface_result.active_voxel_len, 1);
    imageStore(surface, uvi, uvec4(properties, 0, 0, 0));

    // --- Start of the new randomized grass generation ---

    // Define the spacing for grass placement. A value of 2 means grass can only
    // spawn on a 2x2 grid, ensuring space between potential stalks.
    const uint grid_size = 2;

    // Only consider placing grass on the grid points.
    if (uvi.x % grid_size == 0 && uvi.z % grid_size == 0) {
        // Grass should only grow on top surfaces that are not too steep
        if (is_surface_top(uvi) && is_normal_valid && normal_not_too_steep(normal, 0.8) &&
            is_surface_plantable(voxel_type)) {
            // --- Noise-based placement (density) ---
            fnl_state density_noise_state  = fnlCreateState(42); // Seed for density
            density_noise_state.noise_type = FNL_NOISE_PERLIN;
            density_noise_state.frequency  = 0.06; // Lower frequency for larger patches

            // fnlGetNoise returns [-1, 1], so we map it to [0, 1]
            float density_noise = fnlGetNoise2D(density_noise_state, uvi.x, uvi.z) * 0.5 + 0.5;

            // Threshold to control how dense the grass is. Higher = less dense.
            float density_threshold = 0.6;
            if (density_noise > density_threshold) {
                // --- Noise-based height variation ---
                // Use a different seed for the height noise to decouple it from placement
                fnl_state height_noise_state  = fnlCreateState(1337); // Seed for height
                height_noise_state.noise_type = FNL_NOISE_PERLIN;
                height_noise_state.frequency =
                    0.8; // Higher frequency for more local height variation

                // Map noise from [-1, 1] to [0, 1]
                float height_noise = fnlGetNoise2D(height_noise_state, uvi.x, uvi.z) * 0.5 + 0.5;

                // Define the min and max possible height for a stalk of grass
                const uint min_grass_height = 4;
                const uint max_grass_height = 8;

                // Calculate the final height based on the noise value
                uint grass_height =
                    min_grass_height + uint(height_noise * (max_grass_height - min_grass_height));

                uint write_idx = atomicAdd(make_surface_result.grass_instance_len, 1);
                GrassInstance instance;
                instance.position =
                    uvec3(make_surface_info.atlas_read_offset + uvi) + uvec3(0, 1, 0);
                instance.grass_type             = GRASS_TYPE_NORMAL;
                grass_instances.data[write_idx] = instance;
            }
        }
    }
}
