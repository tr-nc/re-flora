#version 450

#extension GL_GOOGLE_include_directive : require

#define GROUP_SIZE 8
#define GROUP_SIZE_3 (GROUP_SIZE * GROUP_SIZE * GROUP_SIZE)
layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = GROUP_SIZE) in;

layout(set = 0, binding = 0) readonly uniform U_MakeSurfaceInfo {
    uvec3 atlas_read_offset;
    uvec3 atlas_read_dim;
    uint is_crossing_boundary; // bool
}
make_surface_info;

layout(set = 0, binding = 1) buffer B_MakeSurfaceResult {
    uint active_voxel_len;
    uint grass_instance_len;
}
make_surface_result;

layout(set = 0, binding = 2, r32ui) writeonly uniform uimage3D surface;

layout(set = 0, binding = 3, r8ui) readonly uniform uimage3D atlas;

#include "../../include/grass_instance.glsl"
layout(set = 0, binding = 4) writeonly buffer B_GrassInstances { GrassInstance data[]; }
grass_instances;

#include "../../include/config.glsl"
#include "../../include/core/definitions.glsl"
#include "../../include/core/packer.glsl"
#include "../../include/grass_type.glsl"
#include "../../include/voxel_type.glsl"

#define SHARED_SIZE (GROUP_SIZE + 4) // 4 for halo
#define SHARED_SIZE_3 (SHARED_SIZE * SHARED_SIZE * SHARED_SIZE)
shared uint shared_data[SHARED_SIZE][SHARED_SIZE][SHARED_SIZE];

ivec3 shared_idx_to_atlas_idx(ivec3 chunk_base, ivec3 shared_idx) {
    const ivec3 group_base = ivec3(gl_WorkGroupID) * GROUP_SIZE - 2; // include halo
    ivec3 atlas_idx        = shared_idx + group_base + chunk_base;
    return atlas_idx;
}

ivec3 local_idx_to_shared_idx(ivec3 local_idx) {
    const ivec3 group_base = ivec3(gl_WorkGroupID) * GROUP_SIZE - 2; // include halo
    return local_idx - group_base;
}

uint load_atlas(ivec3 atlas_idx, ivec3 atlas_read_offset, ivec3 atlas_read_dim,
                bool is_crossing_boundary) {
    if (is_crossing_boundary) {
        return imageLoad(atlas, atlas_idx).r;
    } else {
        if (any(lessThan(atlas_idx, atlas_read_offset)) ||
            any(greaterThanEqual(atlas_idx, atlas_read_offset + atlas_read_dim))) {
            return 0;
        }
        return imageLoad(atlas, atlas_idx).r;
    }
}

void preload() {
    // load operations from any texel that is outside of the boundaries of the bound image will
    // return all zeros
    for (uint linear_idx = gl_LocalInvocationIndex; linear_idx < SHARED_SIZE_3;
         linear_idx += GROUP_SIZE_3) {

        uvec3 shared_idx;
        shared_idx.x = linear_idx % SHARED_SIZE;
        shared_idx.y = (linear_idx / SHARED_SIZE) % SHARED_SIZE;
        shared_idx.z = linear_idx / (SHARED_SIZE * SHARED_SIZE);

        ivec3 atlas_idx =
            shared_idx_to_atlas_idx(ivec3(make_surface_info.atlas_read_offset), ivec3(shared_idx));
        uint val = load_atlas(atlas_idx, ivec3(make_surface_info.atlas_read_offset),
                              ivec3(make_surface_info.atlas_read_dim),
                              make_surface_info.is_crossing_boundary != 0);

        shared_data[shared_idx.x][shared_idx.y][shared_idx.z] = val;
    }
}

bool is_solid(uint voxel_type) { return voxel_type != VOXEL_TYPE_EMPTY; }

uint voxel_at_local_idx(ivec3 local_idx) {
    ivec3 shared_idx = local_idx_to_shared_idx(local_idx);
    return shared_data[shared_idx.x][shared_idx.y][shared_idx.z];
}

/// Check if a block is occluded by its neighbours.
/// A block is occluded if all of its neighbours are solid.
bool is_occluded(ivec3 uvi) {
    ivec3 neighbours_to_check[6] = {
        ivec3(1, 0, 0),  ivec3(-1, 0, 0), ivec3(0, 1, 0),
        ivec3(0, -1, 0), ivec3(0, 0, 1),  ivec3(0, 0, -1),
    };

    for (int i = 0; i < 6; i++) {
        ivec3 cur = uvi + neighbours_to_check[i];

        uint voxel_type = voxel_at_local_idx(cur);

        if (!is_solid(voxel_type)) {
            return false;
        }
    }
    return true;
}

// https://www.youtube.com/watch?v=YTZBFz3Et40
void calculate_normal(out vec3 o_normal, out bool o_is_normal_valid, ivec3 uvi) {
    const ivec3 min_bound = ivec3(-2);
    const ivec3 max_bound = ivec3(2);

    vec3 normal = vec3(0.0);
    for (int z = min_bound.z; z <= max_bound.z; z++) {
        for (int y = min_bound.y; y <= max_bound.y; y++) {
            for (int x = min_bound.x; x <= max_bound.x; x++) {
                ivec3 offset = ivec3(x, y, z);

                // center voxel is not skipped for performance reasons

                ivec3 cur       = uvi + offset;
                uint voxel_type = voxel_at_local_idx(cur);

                // no weighting is applied for the normal calculation

                if (is_solid(voxel_type)) {
                    normal += vec3(offset);
                }
            }
        }
    }
    o_is_normal_valid = length(normal) > EPSILON;
    if (o_is_normal_valid) {
        o_normal = normalize(-normal);
    }
}

/// Threhold ranges from 0.0 to 1.0.
bool normal_not_too_steep(vec3 normal, float threhold) {
    vec3 up = vec3(0.0, 1.0, 0.0);
    return dot(normal, up) > threhold;
}

/// Compress a coordinate into a single uint.
/// The coordinate is compressed into 3 10-bit components.
/// Total occupied bits: 10 * 3 = 30 bits.
uint compress_coord(ivec3 coord) {
    uint coord_compressed = coord.x;
    coord_compressed |= coord.y << 10;
    coord_compressed |= coord.z << 20;
    return coord_compressed;
}

/// Compress a voxel type and normal vector into a single uint.
/// The voxel type is compressed into 8 bits, the normal vector is compressed into 3 7-bit
/// components, and the is_normal_valid flag is compressed into 1 bit.
/// Total occupied bits: 8 + 21 + 1 = 30 bits.
uint compress_voxel_type_and_normal(uint voxel_type, vec3 normal, bool is_normal_valid) {
    uint properties_data = 0;
    properties_data |= voxel_type & 0xFF;
    properties_data |= pack_normal_v2(normal) << 8; // 7 bits for each component -> total 21 bits
    properties_data |= (is_normal_valid ? 1 : 0) << 29; // 1 bit for is_normal_valid
    return properties_data;
}

void main() {
    preload();
    barrier();

    ivec3 uvi = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(uvi, ivec3(make_surface_info.atlas_read_dim)))) {
        return;
    }

    uint voxel_type = voxel_at_local_idx(uvi);
    if (!is_solid(voxel_type)) {
        imageStore(surface, uvi, uvec4(0, 0, 0, 0));
        return;
    }

    if (is_occluded(uvi)) {
        imageStore(surface, uvi, uvec4(0, 0, 0, 0));
        return;
    }

    vec3 normal;
    bool is_normal_valid;
    calculate_normal(normal, is_normal_valid, uvi);
    uint properties = compress_voxel_type_and_normal(voxel_type, normal, is_normal_valid);

    // TODO: maybe do atomic add once in a local workgroup?
    atomicAdd(make_surface_result.active_voxel_len, 1);
    imageStore(surface, uvi, uvec4(properties, 0, 0, 0));

    //

    if (uvi.x % 8 == 0 && uvi.z % 8 == 0 && normal_not_too_steep(normal, 0.9)) {
        uint write_idx = atomicAdd(make_surface_result.grass_instance_len, 1);
        GrassInstance instance;
        instance.position               = uvec3(make_surface_info.atlas_read_offset + uvi);
        instance.grass_type             = GRASS_TYPE_NORMAL;
        grass_instances.data[write_idx] = instance;
    }
}
