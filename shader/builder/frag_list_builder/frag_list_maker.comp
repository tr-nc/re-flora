#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 0, binding = 0) readonly buffer U_NeighborInfo { uint data[]; }
neighbor_info;

layout(set = 0, binding = 1) readonly buffer B_RawBlocks { uint data[]; }
raw_blocks;

// fragment_list_len is incremented atomically every time a new fragment is added
// to the fragment list
layout(set = 0, binding = 2) buffer B_FragListBuildResult { uint fragment_list_len; }
frag_list_build_result;

// fragment list is appended with new fragments that satisfy certain conditions
// (e.g. not occluded, solid, etc.), and is used to build the octree later
// the cursor is determined by fragment_list_info.fragment_list_len
#include "../../include/fragment_list_entry.glsl"
layout(set = 0, binding = 3) writeonly buffer B_FragmentList { FragmentListEntry data[]; }
fragment_list;

#include "../../include/config.glsl"
#include "../../include/core/packer.glsl"
#include "../../include/voxel_types.glsl"

// Serialize 3D coordinates into a single uint value
// Input: 3D coordinates where each component ranges from 0-2
// Output: serialized value from 0-26
uint serialize(ivec3 idx) { return idx.x + idx.y * 3 + idx.z * 9; }

/// idx ranges from -1 to 1 in each axis
bool get_chunk_offset_by_idx(out uint o_offset, ivec3 idx) {
    uint serialized = serialize(idx + 1);
    o_offset        = neighbor_info.data[serialized];
    return o_offset != 0xFFFFFFFF;
}

bool is_solid(uint voxel_type) { return voxel_type != VOXEL_TYPE_EMPTY; }

uint vidx_to_linear(ivec3 p, ivec3 dim) {
    return uint(p.x) + uint(p.y) * uint(dim.x) + uint(p.z) * uint(dim.x * dim.y);
}

ivec3 determine_neighbor_idx(ivec3 idx, ivec3 voxel_dim) {
    ivec3 neighbor_idx = ivec3(0);

    bvec3 below_mask = lessThan(idx, ivec3(0));
    bvec3 above_mask = greaterThanEqual(idx, voxel_dim);

    neighbor_idx -= ivec3(below_mask);
    neighbor_idx += ivec3(above_mask);

    return neighbor_idx;
}

uint get_voxel_type(uint read_offset, ivec3 idx, ivec3 voxel_dim) {
    uint v           = vidx_to_linear(idx, voxel_dim) + read_offset;
    uint uint_offset = v / 4u;
    uint byte_offset = (v % 4u) * 8u;

    uint data = raw_blocks.data[uint_offset];
    data >>= byte_offset;
    data &= 0xFF; // mask to get the last 8 bits

    return data;
}

/// Wrap coord into 0â€¦dim-1
ivec3 wrap_coord(ivec3 c, ivec3 dim) { return (c + dim) % dim; }

/// Check if a block is occluded by its neighbours.
/// A block is occluded if all of its neighbours are solid.
bool is_occluded(ivec3 uvi, ivec3 voxel_dim) {
    ivec3 neighbours_to_check[6] = {
        ivec3(1, 0, 0),  ivec3(-1, 0, 0), ivec3(0, 1, 0),
        ivec3(0, -1, 0), ivec3(0, 0, 1),  ivec3(0, 0, -1),
    };

    for (int i = 0; i < 6; i++) {
        ivec3 cur = uvi + neighbours_to_check[i];

        uint read_offset;
        if (!get_chunk_offset_by_idx(read_offset, determine_neighbor_idx(cur, voxel_dim))) {
            continue;
        }

        ivec3 wrapped   = wrap_coord(cur, voxel_dim);
        uint voxel_type = get_voxel_type(read_offset, wrapped, voxel_dim);

        if (!is_solid(voxel_type)) {
            return false;
        }
    }
    return true;
}

// https://www.youtube.com/watch?v=YTZBFz3Et40
vec3 calculate_normal(ivec3 uvi, ivec3 voxel_dim) {
    const ivec3 min_bound = ivec3(-2);
    const ivec3 max_bound = ivec3(2);

    vec3 normal = vec3(0.0);
    for (int z = min_bound.z; z <= max_bound.z; z++) {
        for (int y = min_bound.y; y <= max_bound.y; y++) {
            for (int x = min_bound.x; x <= max_bound.x; x++) {
                ivec3 offset = ivec3(x, y, z);

                // center voxel is not skipped for performance reasons

                ivec3 cur          = uvi + offset;
                ivec3 neighbor_idx = determine_neighbor_idx(cur, voxel_dim);

                uint read_offset;
                if (!get_chunk_offset_by_idx(read_offset, neighbor_idx)) {
                    continue;
                }

                ivec3 wrapped   = wrap_coord(cur, voxel_dim);
                uint voxel_type = get_voxel_type(read_offset, wrapped, voxel_dim);

                // no weighting is applied for the normal calculation
                if (is_solid(voxel_type)) {
                    normal += vec3(offset);
                }
            }
        }
    }
    return normalize(-normal);
}

/// Compress a coordinate into a single uint.
/// The coordinate is compressed into 3 10-bit components.
/// Therefore there's additional 32-30=2 bits left for other data.
uint compress_coord(ivec3 coord) {
    uint coord_compressed = coord.x;
    coord_compressed |= coord.y << 10;
    coord_compressed |= coord.z << 20;
    return coord_compressed;
}

uint compress_voxel_type_and_normal(uint voxel_type, vec3 normal) {
    uint properties_data = 0;
    properties_data |= voxel_type & 0xFF;
    properties_data |= pack_normal_v2(normal) << 8;
    return properties_data;
}

FragmentListEntry make_fragment_list_entry(ivec3 coord, uint voxel_type, vec3 normal) {
    FragmentListEntry fragment_list_entry;
    fragment_list_entry.coordinates = compress_coord(coord);
    fragment_list_entry.properties  = compress_voxel_type_and_normal(voxel_type, normal);
    return fragment_list_entry;
}

void main() {
    ivec3 uvi       = ivec3(gl_GlobalInvocationID);
    ivec3 voxel_dim = ivec3(VOXEL_DIM);
    if (any(greaterThanEqual(uvi, voxel_dim))) {
        return;
    }

    // Cache the block type so we don't perform multiple image loads.
    uint read_offset;
    // this won't fail because we are asking for the current chunk's offset
    get_chunk_offset_by_idx(read_offset, ivec3(0));
    uint voxel_type = get_voxel_type(read_offset, uvi, voxel_dim);
    if (!is_solid(voxel_type)) {
        return;
    }
    if (is_occluded(uvi, voxel_dim)) {
        return;
    }

    FragmentListEntry entry =
        make_fragment_list_entry(uvi, voxel_type, calculate_normal(uvi, voxel_dim));

    uint fragment_list_cursor = atomicAdd(frag_list_build_result.fragment_list_len, 1);
    fragment_list.data[fragment_list_cursor] = entry;
}
