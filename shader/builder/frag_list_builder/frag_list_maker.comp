#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 0, binding = 0) readonly uniform U_FragListMakerInfo { uvec3 chunk_pos; }
frag_list_maker_info;

// fragment_list_len is incremented atomically every time a new fragment is added
// to the fragment list
layout(set = 0, binding = 1) buffer B_FragListBuildResult { uint fragment_list_len; }
frag_list_build_result;

// fragment list is appended with new fragments that satisfy certain conditions
// (e.g. not occluded, solid, etc.), and is used to build the octree later
// the cursor is determined by fragment_list_info.fragment_list_len
#include "../../include/fragment_list_entry.glsl"
layout(set = 0, binding = 2) writeonly buffer B_FragmentList { FragmentListEntry data[]; }
fragment_list;

layout(set = 0, binding = 3, r8ui) readonly uniform uimage3D raw_atlas;

#include "../../include/config.glsl"
#include "../../include/core/packer.glsl"
#include "../../include/voxel_types.glsl"

// Serialize 3D coordinates into a single uint value
// Input: 3D coordinates where each component ranges from 0-2
// Output: serialized value from 0-26
uint serialize(ivec3 idx) { return idx.x + idx.y * 3 + idx.z * 9; }

bool is_solid(uint voxel_type) { return voxel_type != VOXEL_TYPE_EMPTY; }

uint get_voxel_type(ivec3 idx_in_atlas) {
    // https://www.khronos.org/opengl/wiki/Image_Load_Store
    // load operations from any texel that is outside of the boundaries of the bound image will
    // return all zeros.
    uint data = imageLoad(raw_atlas, idx_in_atlas).r;
    return data;
}

/// Wrap coord into 0â€¦dim-1
ivec3 wrap_coord(ivec3 c, ivec3 dim) { return (c + dim) % dim; }

/// Check if a block is occluded by its neighbours.
/// A block is occluded if all of its neighbours are solid.
bool is_occluded(ivec3 uvi) {
    ivec3 neighbours_to_check[6] = {
        ivec3(1, 0, 0),  ivec3(-1, 0, 0), ivec3(0, 1, 0),
        ivec3(0, -1, 0), ivec3(0, 0, 1),  ivec3(0, 0, -1),
    };

    for (int i = 0; i < 6; i++) {
        ivec3 cur = uvi + neighbours_to_check[i];

        ivec3 idx_in_atlas = cur + ivec3(frag_list_maker_info.chunk_pos) * VOXEL_DIM;
        uint voxel_type    = get_voxel_type(idx_in_atlas);

        if (!is_solid(voxel_type)) {
            return false;
        }
    }
    return true;
}

// https://www.youtube.com/watch?v=YTZBFz3Et40
vec3 calculate_normal(ivec3 uvi, ivec3 voxel_dim) {
    const ivec3 min_bound = ivec3(-2);
    const ivec3 max_bound = ivec3(2);

    vec3 normal = vec3(0.0);
    for (int z = min_bound.z; z <= max_bound.z; z++) {
        for (int y = min_bound.y; y <= max_bound.y; y++) {
            for (int x = min_bound.x; x <= max_bound.x; x++) {
                ivec3 offset = ivec3(x, y, z);

                // center voxel is not skipped for performance reasons

                ivec3 cur = uvi + offset;

                ivec3 idx_in_atlas = cur + ivec3(frag_list_maker_info.chunk_pos) * VOXEL_DIM;
                uint voxel_type    = get_voxel_type(idx_in_atlas);

                // no weighting is applied for the normal calculation

                if (is_solid(voxel_type)) {
                    normal += vec3(offset);
                }
            }
        }
    }
    return normalize(-normal);
}

/// Compress a coordinate into a single uint.
/// The coordinate is compressed into 3 10-bit components.
/// Therefore there's additional 32-30=2 bits left for other data.
uint compress_coord(ivec3 coord) {
    uint coord_compressed = coord.x;
    coord_compressed |= coord.y << 10;
    coord_compressed |= coord.z << 20;
    return coord_compressed;
}

uint compress_voxel_type_and_normal(uint voxel_type, vec3 normal) {
    uint properties_data = 0;
    properties_data |= voxel_type & 0xFF;
    properties_data |= pack_normal_v2(normal) << 8;
    return properties_data;
}

FragmentListEntry make_fragment_list_entry(ivec3 coord, uint voxel_type, vec3 normal) {
    FragmentListEntry fragment_list_entry;
    fragment_list_entry.coordinates = compress_coord(coord);
    fragment_list_entry.properties  = compress_voxel_type_and_normal(voxel_type, normal);
    return fragment_list_entry;
}

void main() {
    ivec3 uvi       = ivec3(gl_GlobalInvocationID);
    ivec3 voxel_dim = ivec3(VOXEL_DIM);
    if (any(greaterThanEqual(uvi, voxel_dim))) {
        return;
    }

    ivec3 idx_in_atlas = uvi + ivec3(frag_list_maker_info.chunk_pos) * VOXEL_DIM;
    uint voxel_type    = get_voxel_type(idx_in_atlas);
    if (!is_solid(voxel_type)) {
        return;
    }
    if (is_occluded(uvi)) {
        return;
    }

    FragmentListEntry entry =
        make_fragment_list_entry(uvi, voxel_type, calculate_normal(uvi, voxel_dim));

    uint fragment_list_cursor = atomicAdd(frag_list_build_result.fragment_list_len, 1);
    fragment_list.data[fragment_list_cursor] = entry;
}
