#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// stores information of the current chunk to build
layout(set = 0, binding = 0) readonly uniform U_ChunkBuildInfo {
    uvec3 chunk_res;
    ivec3 chunk_pos;
}
chunk_build_info;

layout(set = 1, binding = 0) readonly buffer B_RawBlocks { uint data[]; }
raw_blocks;

// fragment_list_len is incremented atomically every time a new fragment is added
// to the fragment list
layout(set = 1, binding = 1) buffer B_FragmentListInfo { uint fragment_list_len; }
fragment_list_info;

// fragment list is appended with new fragments that satisfy certain conditions
// (e.g. not occluded, solid, etc.), and is used to build the octree later
// the cursor is determined by fragment_list_info.fragment_list_len
#include "../include/fragment_list_entry.glsl"
layout(set = 1, binding = 2) writeonly buffer B_FragmentList { FragmentListEntry data[]; }
fragment_list;

#include "../include/core/packer.glsl"
#include "../include/voxel_types.glsl"

bool is_solid(uint voxel_type) { return voxel_type != VOXEL_TYPE_EMPTY; }

uint vidx_to_linear(uvec3 idx, uvec3 chunk_res) {
    return idx.z * chunk_res.x * chunk_res.y + idx.y * chunk_res.x + idx.x;
}

// helper function
uint get_voxel_type(ivec3 idx) {
    uint v           = vidx_to_linear(uvec3(idx), chunk_build_info.chunk_res);
    uint uint_offset = v / 4u;
    uint byte_offset = (v % 4u) * 8u;

    uint data = raw_blocks.data[uint_offset];
    data >>= byte_offset;
    data &= 0xFF; // mask to get the last 8 bits

    return data;
}

/// Check if a block is occluded by its neighbours.
/// A block is occluded if all of its neighbours are solid.
bool is_occluded(ivec3 uvi) {
    ivec3 neighbours_to_check[6] = {
        ivec3(1, 0, 0),  ivec3(-1, 0, 0), ivec3(0, 1, 0),
        ivec3(0, -1, 0), ivec3(0, 0, 1),  ivec3(0, 0, -1),
    };

    for (int i = 0; i < 6; i++) {
        ivec3 cur = uvi + neighbours_to_check[i];

        // TODO: check neighbouring chunks later.
        // for now, just say that it is not occluded.
        if (any(lessThan(cur, ivec3(0))) ||
            any(greaterThanEqual(cur, ivec3(chunk_build_info.chunk_res)))) {
            return false;
        }

        if (!is_solid(get_voxel_type(cur))) {
            return false;
        }
    }
    return true;
}

// https://www.youtube.com/watch?v=YTZBFz3Et40
vec3 calculate_normal(ivec3 uvi) {
    vec3 uvi_f = vec3(uvi);

    ivec3 min_bound = uvi - 2;
    ivec3 max_bound = uvi + 2;

    // TODO: consider neighbouring chunks later.
    min_bound = max(min_bound, ivec3(0));
    max_bound = min(max_bound, ivec3(chunk_build_info.chunk_res - 1));

    vec3 normal = vec3(0.0);

    for (int z = min_bound.z; z <= max_bound.z; z++) {
        for (int y = min_bound.y; y <= max_bound.y; y++) {
            for (int x = min_bound.x; x <= max_bound.x; x++) {
                ivec3 cur       = ivec3(x, y, z);
                uint voxel_type = get_voxel_type(cur);

                if (is_solid(voxel_type)) {
                    normal += vec3(x, y, z) - uvi_f;
                }
            }
        }
    }
    return normalize(-normal);
}

/// Compress a uvec3 coordinate into a single uint.
/// The coordinate is compressed into 3 10-bit components.
/// Therefore there's additional 32-30=2 bits left for other data.
uint compress_coord(uvec3 coord) {
    uint coord_compressed = coord.x;
    coord_compressed |= coord.y << 10;
    coord_compressed |= coord.z << 20;
    return coord_compressed;
}

uint compress_voxel_type_and_normal(uint voxel_type, vec3 normal) {
    uint properties_data = 0;
    properties_data |= voxel_type & 0xFF;
    properties_data |= pack_normal_v2(normal) << 8;
    return properties_data;
}

FragmentListEntry make_fragment_list_entry(uvec3 coord, uint voxel_type, vec3 normal) {
    FragmentListEntry fragment_list_entry;
    fragment_list_entry.coordinates = compress_coord(coord);
    fragment_list_entry.properties  = compress_voxel_type_and_normal(voxel_type, normal);
    return fragment_list_entry;
}

void main() {
    ivec3 uvi = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(uvi, ivec3(chunk_build_info.chunk_res)))) {
        return;
    }

    // Cache the block type so we don't perform multiple image loads.
    uint voxel_type = get_voxel_type(uvi);
    if (!is_solid(voxel_type)) {
        return;
    }
    if (is_occluded(uvi)) {
        return;
    }

    uint fragment_list_cursor = atomicAdd(fragment_list_info.fragment_list_len, 1);

    // Pass the cached voxel_type to the fragment_list entry.
    FragmentListEntry entry =
        make_fragment_list_entry(uvec3(uvi), voxel_type, calculate_normal(uvi));
    fragment_list.data[fragment_list_cursor] = entry;
}
