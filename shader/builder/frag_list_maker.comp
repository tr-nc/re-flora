#version 450

#extension GL_GOOGLE_include_directive : require
// #extension GL_EXT_shader_image_load_formatted : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 0, binding = 0) uniform ChunkBuildInfo {
    uvec3 chunk_res;
    ivec3 chunk_pos;
}
chunk_build_info;

layout(set = 1, binding = 0, r8ui) readonly uniform uimage3D weight_image;

layout(set = 1, binding = 1) buffer FragmentListInfo { uint current_fragment_list_len; }
fragment_list_info;

#include "../include/fragment_list_entry.glsl"
layout(set = 1, binding = 2) buffer FragmentList { FragmentListEntry data[]; }
fragment_list;

#include "../include/block_types.glsl"

bool is_solid(uint block_type) { return block_type != BLOCK_TYPE_EMPTY; }

uint get_block_type(ivec3 uvi) { return imageLoad(weight_image, uvi).x; }

/// Check if a block is occluded by its neighbours.
/// A block is occluded if all of its neighbours are solid.
bool is_occluded(ivec3 uvi) {
    ivec3 neighbours_to_check[6] = {
        ivec3(1, 0, 0),  ivec3(-1, 0, 0), ivec3(0, 1, 0),
        ivec3(0, -1, 0), ivec3(0, 0, 1),  ivec3(0, 0, -1),
    };

    for (int i = 0; i < 6; i++) {
        ivec3 neighbour = neighbours_to_check[i];
        ivec3 cur       = uvi + neighbour;

        // TODO: check neighbouring chunks later.
        // for now, just say that it is not occluded.
        if (any(lessThan(cur, ivec3(0))) ||
            any(greaterThanEqual(cur, ivec3(chunk_build_info.chunk_res)))) {
            return false;
        }

        if (!is_solid(get_block_type(cur))) {
            return false;
        }
    }
    return true;
}

// https://www.youtube.com/watch?v=YTZBFz3Et40
vec3 calculate_normal(ivec3 uvi) {
    ivec3 min_bound = uvi - 2;
    ivec3 max_bound = uvi + 2;

    // TODO: consider neighbouring chunks later.
    min_bound = max(min_bound, ivec3(0));
    max_bound = min(max_bound, ivec3(chunk_build_info.chunk_res));

    vec3 normal = vec3(0.0);

    for (int z = min_bound.z; z <= max_bound.z; z++) {
        for (int y = min_bound.y; y <= max_bound.y; y++) {
            for (int x = min_bound.x; x <= max_bound.x; x++) {
                ivec3 cur = ivec3(x, y, z);

                uint block_type = get_block_type(cur);

                if (is_solid(block_type)) {
                    normal += vec3(x, y, z) - vec3(uvi);
                }
            }
        }
    }
    return normalize(normal);
}

/// Compress a normal vector into a single uint.
/// The normal vector is compressed into 3 7-bit components.
/// Therefore there's additional 32-21=11 bits left for other data.
uint compress_normal(vec3 normal) {
    // scale and bias from [-1, 1] to [0, 127]
    uvec3 quantized = uvec3(((normal + 1) * 0.5) * 127.0);
    // pack the 7-bit components into a single uint
    uint packed = (quantized.r) | (quantized.g << 7) | (quantized.b << 14);
    return packed;
}

/// Compress a ivec3 coordinate into a single uint.
/// The coordinate is compressed into 3 10-bit components.
/// Therefore there's additional 32-30=2 bits left for other data.
uint compress_coord(ivec3 coord) {
    uint coord_compressed = coord.x;
    coord_compressed |= coord.y << 10;
    coord_compressed |= coord.z << 20;
    return coord_compressed;
}

uint compress_block_type_and_normal(uint block_type, vec3 normal) {
    uint properties_data = 0;
    properties_data |= block_type & 0xFF;
    properties_data |= compress_normal(normal) << 8;
    return properties_data;
}

FragmentListEntry make_fragment_list_entry(ivec3 coord, uint block_type, vec3 normal) {
    FragmentListEntry fragment_list_entry;

    fragment_list_entry.coordinates = compress_coord(coord);
    fragment_list_entry.properties  = compress_block_type_and_normal(block_type, normal);
    return fragment_list_entry;
}

void main() {
    ivec3 uvi = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(uvi, ivec3(chunk_build_info.chunk_res)))) {
        return;
    }

    // if the block is not solid, we don't need to add it to the fragment list.
    if (!is_solid(get_block_type(uvi))) {
        return;
    }

    // if the block is occluded, we don't need to add it to the fragment list.
    if (is_occluded(uvi)) {
        return;
    }

    uint fragment_list_cursor = atomicAdd(fragment_list_info.current_fragment_list_len, 1);

    FragmentListEntry entry =
        make_fragment_list_entry(uvi, get_block_type(uvi), calculate_normal(uvi));

    fragment_list.data[fragment_list_cursor] = entry;
}
