#version 450

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly uniform U_ChunkBuildInfo {
    uvec3 chunk_res;
    ivec3 chunk_pos;
}
chunk_build_info;
layout(set = 1, binding = 0, r8ui) readonly uniform uimage3D raw_blocks_img;

layout(set = 1, binding = 1) writeonly buffer B_RawBlocks { uint data[]; }
raw_blocks;

uvec3 linear_to_vidx(uint idx, uvec3 chunk_res) {
    uint slice     = idx / (chunk_res.x * chunk_res.y);
    uint remainder = idx % (chunk_res.x * chunk_res.y);
    uint y         = remainder / chunk_res.x;
    uint x         = remainder % chunk_res.x;
    return uvec3(x, y, slice);
}

uint get_current_byte(uint x, uvec3 chunk_res) {
    uint v1 = x * 4u;
    uint v2 = v1 + 1u;
    uint v3 = v1 + 2u;
    uint v4 = v1 + 3u;

    uvec3 v1_3d = linear_to_vidx(v1, chunk_res);
    uvec3 v2_3d = linear_to_vidx(v2, chunk_res);
    uvec3 v3_3d = linear_to_vidx(v3, chunk_res);
    uvec3 v4_3d = linear_to_vidx(v4, chunk_res);

    uint v1_data = imageLoad(raw_blocks_img, ivec3(v1_3d)).x;
    uint v2_data = imageLoad(raw_blocks_img, ivec3(v2_3d)).x;
    uint v3_data = imageLoad(raw_blocks_img, ivec3(v3_3d)).x;
    uint v4_data = imageLoad(raw_blocks_img, ivec3(v4_3d)).x;

    uint current_byte_data = (v4_data << 24) | (v3_data << 16) | (v2_data << 8) | v1_data;
    return current_byte_data;
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint total_voxel_size =
        chunk_build_info.chunk_res.x * chunk_build_info.chunk_res.y * chunk_build_info.chunk_res.z;
    uint total_buffer_size = total_voxel_size / 4;

    if (x >= total_buffer_size) {
        return;
    }

    uint current_byte_data = get_current_byte(x, chunk_build_info.chunk_res);
    raw_blocks.data[x]     = current_byte_data;
}
