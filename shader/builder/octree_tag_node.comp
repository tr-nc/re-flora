#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// TODO: check if adding these specifiers actually improves performance
layout(set = 1, binding = 1) readonly buffer B_VoxelCount { uint voxel_count; };
layout(set = 1, binding = 2) buffer B_PerVoxelBuildInfo {
  PerVoxelBuildInfo per_voxel_build_infos[];
};

uvec4 leaf_to_uvec4(uint val) {
  return uvec4((val & 0xFF), ((val >> 8) & 0xFF), ((val >> 16) & 0xFF), ((val >> 24) & 0x3F));
}
uint uvec4_to_leaf(uvec4 vec) {
  return (min(vec.w, 0x3F) << 24) | (vec.x & 0xFF) | ((vec.y & 0xFF) << 8) |
         ((vec.z & 0xFF) << 16) | 0xC0000000;
}

// returns the index of the node to be tagged (it has just been initialized to
// 0)
uint traverse_octree(in const uvec3 voxel_pos, out bool is_leaf) {
  uint level_dim  = fragmentListInfoBuffer.data.voxelResolution;
  uvec3 level_pos = voxel_pos;

  uint idx = 0u, cur = 0u;
  do {
    // fast division by 2, level_dim is always 2^n, n >= 0
    bvec3 cmp = greaterThanEqual(level_pos, uvec3(level_dim >>= 1));
    idx       = cur | uint(cmp.x) | (uint(cmp.y) << 1) | (uint(cmp.z) << 2);
    cur       = octreeBuffer.data[idx] & 0x3FFFFFFF; // read node pointer
    level_pos -= uvec3(cmp) * level_dim;
  } while (cur != 0 && level_dim > 1u);
  is_leaf = level_dim == 1u;
  return idx;
}

void main() {
  if (gl_GlobalInvocationID.x >= voxel_count) return;
  G_FragmentListEntry ufragment = fragmentListBuffer.datas[gl_GlobalInvocationID.x];

  uint coordinates = ufragment.coordinates;
  uvec3 voxel_pos  = uvec3((coordinates & 0x000003FF), (coordinates & 0x000FFC00) >> 10,
                           (coordinates & 0x3FF00000) >> 20);

  bool is_leaf;
  // is_leaf is only true when the leaf node is allocated
  uint idx = traverse_octree(voxel_pos, is_leaf);

  if (is_leaf) {
    uint properties        = ufragment.properties;
    octreeBuffer.data[idx] = 0xC0000000u | properties;
  } else
    // flag the node so it can be subdivided (using msb)
    octreeBuffer.data[idx] = 0x80000000u;
}
