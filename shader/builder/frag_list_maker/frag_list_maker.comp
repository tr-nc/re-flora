#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// stores information of the current chunk to build
layout(set = 0, binding = 0) readonly uniform U_FragListMakerInfo { uvec3 chunk_res; }
frag_list_maker_info;

layout(set = 0, binding = 1) readonly buffer U_NeighborInfo { uint data[]; }
neighbor_info;

layout(set = 0, binding = 2) readonly buffer B_RawBlocks { uint data[]; }
raw_blocks;

// fragment_list_len is incremented atomically every time a new fragment is added
// to the fragment list
layout(set = 0, binding = 3) buffer B_FragmentListInfo { uint fragment_list_len; }
fragment_list_info;

// fragment list is appended with new fragments that satisfy certain conditions
// (e.g. not occluded, solid, etc.), and is used to build the octree later
// the cursor is determined by fragment_list_info.fragment_list_len
#include "../../include/fragment_list_entry.glsl"
layout(set = 0, binding = 4) writeonly buffer B_FragmentList { FragmentListEntry data[]; }
fragment_list;

#include "../../include/core/packer.glsl"
#include "../../include/voxel_types.glsl"

// Deserialize a number back to 3D coordinates
// Input: serialized value from 0-26
// Output: 3D coordinates where each component ranges from 0-2
// uvec3 deserialize(uint serialized) {
//     uint z         = serialized / 9; // Integer division for z component
//     uint remainder = serialized % 9;
//     uint y         = remainder / 3; // Integer division for y component
//     uint x         = remainder % 3; // Remainder for x component

//     return uvec3(x, y, z);
// }

// Serialize 3D coordinates into a single uint value
// Input: 3D coordinates where each component ranges from 0-2
// Output: serialized value from 0-26
uint serialize(uvec3 idx) { return idx.x + idx.y * 3 + idx.z * 9; }

/// idx ranges from -1 to 1 in each axis
bool get_neighbor_offset(out uint o_offset, ivec3 idx) {
    uvec3 idx_u = uvec3(idx + 1);

    uint serialized = serialize(idx_u);

    // read idx protection, can be deleted
    if (serialized > 26) {
        return false;
    }

    o_offset = neighbor_info.data[serialized];
}

bool is_solid(uint voxel_type) { return voxel_type != VOXEL_TYPE_EMPTY; }

uint vidx_to_linear(uvec3 idx, uvec3 chunk_res) {
    return idx.z * chunk_res.x * chunk_res.y + idx.y * chunk_res.x + idx.x;
}

ivec3 determine_neighbor_idx(ivec3 idx) {
    ivec3 neighbor_idx = ivec3(0);
    if (idx.x < 0) {
        neighbor_idx.x = -1;
    } else if (idx.x > frag_list_maker_info.chunk_res.x) {
        neighbor_idx.x = 1;
    } else if (idx.y < 0) {
        neighbor_idx.y = -1;
    } else if (idx.y > frag_list_maker_info.chunk_res.y) {
        neighbor_idx.y = 1;
    } else if (idx.z < 0) {
        neighbor_idx.z = -1;
    } else if (idx.z > frag_list_maker_info.chunk_res.z) {
        neighbor_idx.z = 1;
    }
    return neighbor_idx;
}

uint get_voxel_type(uint read_offset, ivec3 idx) {
    uint v           = vidx_to_linear(uvec3(idx), frag_list_maker_info.chunk_res) + read_offset;
    uint uint_offset = v / 4u;
    uint byte_offset = (v % 4u) * 8u;

    uint data = raw_blocks.data[uint_offset];
    data >>= byte_offset;
    data &= 0xFF; // mask to get the last 8 bits

    return data;
}

/// Check if a block is occluded by its neighbours.
/// A block is occluded if all of its neighbours are solid.
bool is_occluded(ivec3 uvi) {
    ivec3 neighbours_to_check[6] = {
        ivec3(1, 0, 0),  ivec3(-1, 0, 0), ivec3(0, 1, 0),
        ivec3(0, -1, 0), ivec3(0, 0, 1),  ivec3(0, 0, -1),
    };

    for (int i = 0; i < 6; i++) {
        ivec3 cur = uvi + neighbours_to_check[i];

        if (any(lessThan(cur, ivec3(0))) ||
            any(greaterThanEqual(cur, ivec3(frag_list_maker_info.chunk_res)))) {
            return false;
        }

        // ivec3 neighbor_idx = determine_neighbor_idx(cur);

        // uint offset;
        // bool is_present = get_neighbor_offset(offset, neighbor_idx);
        // if (!is_present) {
        //     continue;
        // }

        // if (cur.x < 0) {
        //     cur.x += int(frag_list_maker_info.chunk_res.x);
        // }
        // if (cur.y < 0) {
        //     cur.y += int(frag_list_maker_info.chunk_res.y);
        // }
        // if (cur.z < 0) {
        //     cur.z += int(frag_list_maker_info.chunk_res.z);
        // }
        // if (cur.x >= frag_list_maker_info.chunk_res.x) {
        //     cur.x -= int(frag_list_maker_info.chunk_res.x);
        // }
        // if (cur.y >= frag_list_maker_info.chunk_res.y) {
        //     cur.y -= int(frag_list_maker_info.chunk_res.y);
        // }
        // if (cur.z >= frag_list_maker_info.chunk_res.z) {
        //     cur.z -= int(frag_list_maker_info.chunk_res.z);
        // }

        if (!is_solid(get_voxel_type(218103808, cur))) {
            return false;
        }
    }
    return true;
}

// https://www.youtube.com/watch?v=YTZBFz3Et40
vec3 calculate_normal(ivec3 uvi) {
    vec3 uvi_f = vec3(uvi);

    ivec3 min_bound = uvi - 2;
    ivec3 max_bound = uvi + 2;

    min_bound = max(min_bound, ivec3(0));
    max_bound = min(max_bound, ivec3(frag_list_maker_info.chunk_res - 1));

    vec3 normal = vec3(0.0);

    for (int z = min_bound.z; z <= max_bound.z; z++) {
        for (int y = min_bound.y; y <= max_bound.y; y++) {
            for (int x = min_bound.x; x <= max_bound.x; x++) {
                ivec3 cur = ivec3(x, y, z);

                // ivec3 neighbor_idx = determine_neighbor_idx(cur);

                // uint offset;
                // bool is_present = get_neighbor_offset(offset, neighbor_idx);
                // if (!is_present) {
                //     continue;
                // }

                // if (cur.x < 0) {
                //     cur.x += int(frag_list_maker_info.chunk_res.x);
                // }
                // if (cur.y < 0) {
                //     cur.y += int(frag_list_maker_info.chunk_res.y);
                // }
                // if (cur.z < 0) {
                //     cur.z += int(frag_list_maker_info.chunk_res.z);
                // }
                // if (cur.x >= frag_list_maker_info.chunk_res.x) {
                //     cur.x -= int(frag_list_maker_info.chunk_res.x);
                // }
                // if (cur.y >= frag_list_maker_info.chunk_res.y) {
                //     cur.y -= int(frag_list_maker_info.chunk_res.y);
                // }
                // if (cur.z >= frag_list_maker_info.chunk_res.z) {
                //     cur.z -= int(frag_list_maker_info.chunk_res.z);
                // }

                uint voxel_type = get_voxel_type(218103808, cur);

                if (is_solid(voxel_type)) {
                    normal += vec3(x, y, z) - uvi_f;
                }
            }
        }
    }
    return normalize(-normal);
}

/// Compress a uvec3 coordinate into a single uint.
/// The coordinate is compressed into 3 10-bit components.
/// Therefore there's additional 32-30=2 bits left for other data.
uint compress_coord(uvec3 coord) {
    uint coord_compressed = coord.x;
    coord_compressed |= coord.y << 10;
    coord_compressed |= coord.z << 20;
    return coord_compressed;
}

uint compress_voxel_type_and_normal(uint voxel_type, vec3 normal) {
    uint properties_data = 0;
    properties_data |= voxel_type & 0xFF;
    properties_data |= pack_normal_v2(normal) << 8;
    return properties_data;
}

FragmentListEntry make_fragment_list_entry(uvec3 coord, uint voxel_type, vec3 normal) {
    FragmentListEntry fragment_list_entry;
    fragment_list_entry.coordinates = compress_coord(coord);
    fragment_list_entry.properties  = compress_voxel_type_and_normal(voxel_type, normal);
    return fragment_list_entry;
}

void main() {
    ivec3 uvi = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(uvi, ivec3(frag_list_maker_info.chunk_res)))) {
        return;
    }

    // Cache the block type so we don't perform multiple image loads.
    uint voxel_type = get_voxel_type(218103808, uvi);
    if (!is_solid(voxel_type)) {
        return;
    }
    if (is_occluded(uvi)) {
        return;
    }

    uint fragment_list_cursor = atomicAdd(fragment_list_info.fragment_list_len, 1);

    // Pass the cached voxel_type to the fragment_list entry.
    FragmentListEntry entry =
        make_fragment_list_entry(uvec3(uvi), voxel_type, calculate_normal(uvi));

    fragment_list.data[fragment_list_cursor] = entry;
}
