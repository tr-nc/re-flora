#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// stores information of the current chunk to build
layout(set = 0, binding = 0) readonly uniform U_FragListMakerInfo { uvec3 chunk_res; }
frag_list_maker_info;

layout(set = 0, binding = 1) readonly buffer U_NeighborInfo { uint data[]; }
neighbor_info;

layout(set = 0, binding = 2) readonly buffer B_RawBlocks { uint data[]; }
raw_blocks;

// fragment_list_len is incremented atomically every time a new fragment is added
// to the fragment list
layout(set = 0, binding = 3) buffer B_FragmentListInfo { uint fragment_list_len; }
fragment_list_info;

// fragment list is appended with new fragments that satisfy certain conditions
// (e.g. not occluded, solid, etc.), and is used to build the octree later
// the cursor is determined by fragment_list_info.fragment_list_len
#include "../../include/fragment_list_entry.glsl"
layout(set = 0, binding = 4) writeonly buffer B_FragmentList { FragmentListEntry data[]; }
fragment_list;

#include "../../include/core/packer.glsl"
#include "../../include/voxel_types.glsl"

// Serialize 3D coordinates into a single uint value
// Input: 3D coordinates where each component ranges from 0-2
// Output: serialized value from 0-26
uint serialize(uvec3 idx) { return idx.x + idx.y * 3 + idx.z * 9; }

/// idx ranges from -1 to 1 in each axis
bool get_neighbor_offset(out uint o_offset, ivec3 idx) {
    uvec3 idx_u     = uvec3(idx + 1);
    uint serialized = serialize(idx_u);
    o_offset        = neighbor_info.data[serialized];
    return true;
}

bool is_solid(uint voxel_type) { return voxel_type != VOXEL_TYPE_EMPTY; }

uint vidx_to_linear(uvec3 idx, uvec3 chunk_res) {
    return idx.z * chunk_res.x * chunk_res.y + idx.y * chunk_res.x + idx.x;
}

ivec3 determine_neighbor_idx(ivec3 idx) {
    ivec3 neighbor_idx = ivec3(0);
    if (idx.x < 0) {
        neighbor_idx.x = -1;
    } else if (idx.x >= frag_list_maker_info.chunk_res.x) {
        neighbor_idx.x = 1;
    } else if (idx.y < 0) {
        neighbor_idx.y = -1;
    } else if (idx.y >= frag_list_maker_info.chunk_res.y) {
        neighbor_idx.y = 1;
    } else if (idx.z < 0) {
        neighbor_idx.z = -1;
    } else if (idx.z >= frag_list_maker_info.chunk_res.z) {
        neighbor_idx.z = 1;
    }
    return neighbor_idx;
}

uint get_voxel_type(uint read_offset, uvec3 idx) {
    uint v           = vidx_to_linear(idx, frag_list_maker_info.chunk_res) + read_offset;
    uint uint_offset = v / 4u;
    uint byte_offset = (v % 4u) * 8u;

    uint data = raw_blocks.data[uint_offset];
    data >>= byte_offset;
    data &= 0xFF; // mask to get the last 8 bits

    return data;
}

/// Wraps the coordinates to be within the chunk resolution.
uvec3 wrap_coord(ivec3 uvi, uvec3 chunk_res) {
    const ivec3 chunk_res_i = ivec3(chunk_res);
    if (uvi.x < 0) {
        uvi.x += chunk_res_i.x;
    }
    if (uvi.y < 0) {
        uvi.y += chunk_res_i.y;
    }
    if (uvi.z < 0) {
        uvi.z += chunk_res_i.z;
    }
    if (uvi.x >= chunk_res_i.x) {
        uvi.x -= chunk_res_i.x;
    }
    if (uvi.y >= chunk_res_i.y) {
        uvi.y -= chunk_res_i.y;
    }
    if (uvi.z >= chunk_res_i.z) {
        uvi.z -= chunk_res_i.z;
    }
    return uvec3(uvi);
}

/// Check if a block is occluded by its neighbours.
/// A block is occluded if all of its neighbours are solid.
bool is_occluded(ivec3 uvi) {
    ivec3 neighbours_to_check[6] = {
        ivec3(1, 0, 0),  ivec3(-1, 0, 0), ivec3(0, 1, 0),
        ivec3(0, -1, 0), ivec3(0, 0, 1),  ivec3(0, 0, -1),
    };

    for (int i = 0; i < 6; i++) {
        ivec3 cur = uvi + neighbours_to_check[i];

        uint offset;
        bool is_present = get_neighbor_offset(offset, determine_neighbor_idx(cur));
        if (!is_present) {
            continue;
        }

        uvec3 wrapped   = wrap_coord(cur, frag_list_maker_info.chunk_res);
        uint voxel_type = get_voxel_type(offset, wrapped);

        if (!is_solid(voxel_type)) {
            return false;
        }
    }
    return true;
}

// https://www.youtube.com/watch?v=YTZBFz3Et40
vec3 calculate_normal(ivec3 uvi) {
    vec3 uvi_f = vec3(uvi);

    ivec3 min_bound = uvi - 2;
    ivec3 max_bound = uvi + 2;

    vec3 normal = vec3(0.0);

    for (int z = min_bound.z; z <= max_bound.z; z++) {
        for (int y = min_bound.y; y <= max_bound.y; y++) {
            for (int x = min_bound.x; x <= max_bound.x; x++) {
                ivec3 cur = ivec3(x, y, z);

                ivec3 neighbor_idx = determine_neighbor_idx(cur);

                uint offset;
                bool is_present = get_neighbor_offset(offset, neighbor_idx);
                if (!is_present) {
                    continue;
                }

                uvec3 wrapped   = wrap_coord(cur, frag_list_maker_info.chunk_res);
                uint voxel_type = get_voxel_type(offset, wrapped);

                if (is_solid(voxel_type)) {
                    normal += vec3(x, y, z) - uvi_f;
                }
            }
        }
    }
    return normalize(-normal);
}

/// Compress a uvec3 coordinate into a single uint.
/// The coordinate is compressed into 3 10-bit components.
/// Therefore there's additional 32-30=2 bits left for other data.
uint compress_coord(uvec3 coord) {
    uint coord_compressed = coord.x;
    coord_compressed |= coord.y << 10;
    coord_compressed |= coord.z << 20;
    return coord_compressed;
}

uint compress_voxel_type_and_normal(uint voxel_type, vec3 normal) {
    uint properties_data = 0;
    properties_data |= voxel_type & 0xFF;
    properties_data |= pack_normal_v2(normal) << 8;
    return properties_data;
}

FragmentListEntry make_fragment_list_entry(uvec3 coord, uint voxel_type, vec3 normal) {
    FragmentListEntry fragment_list_entry;
    fragment_list_entry.coordinates = compress_coord(coord);
    fragment_list_entry.properties  = compress_voxel_type_and_normal(voxel_type, normal);
    return fragment_list_entry;
}

void main() {
    ivec3 uvi = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(uvi, ivec3(frag_list_maker_info.chunk_res)))) {
        return;
    }

    // Cache the block type so we don't perform multiple image loads.
    uint voxel_type = get_voxel_type(218103808, uvi);
    if (!is_solid(voxel_type)) {
        return;
    }
    if (is_occluded(uvi)) {
        return;
    }

    uint fragment_list_cursor = atomicAdd(fragment_list_info.fragment_list_len, 1);

    FragmentListEntry entry =
        make_fragment_list_entry(uvec3(uvi), voxel_type, calculate_normal(uvi));

    fragment_list.data[fragment_list_cursor] = entry;
}
